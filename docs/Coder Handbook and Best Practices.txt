Coder Handbook and Best Practices
This section serves as a guide for any developer continuing work on the MNQRSTest strategy. It covers conventions, patterns, and important considerations established so far.
Strategy Parameter Conventions
•	Naming Scheme: Strategy input properties (those marked with [NinjaScriptProperty]) use PascalCase names that often include descriptive prefixes. For example, boolean toggles start with verbs like Use or adjectives like Enable (e.g. UseEntryTimeFilter, UseVolatilityFilter), threshold values often have descriptive names like MinATR or TrendSlopeMin, and weight parameters use W_ prefixes (e.g. W_QSwing, W_QVol) to denote “weight” in composite score calculations. This naming makes the parameter’s purpose immediately clear in the UI.
•	Grouping and Order: We leverage the [Display(Name="...", GroupName="...", Order=...)] attribute to organize parameters in the NinjaTrader UI. Related parameters share a GroupName (e.g. “Entry Filters” for all entry filter toggles and thresholds, “Quality Weights” for the Q_Swing/Q_Momo/etc weights, “Runner” for runner management settings, “VP” for volume profile settings). The Order is used to sort them logically within the group. This ensures that in the strategy’s property grid, users see parameters in a coherent order (e.g. all filters listed together, all weights together, etc.), improving usability.
•	Parameter Suffix “Param”: In earlier iterations, we sometimes created a public property with a “Param” suffix distinct from an internal field. For instance, DefaultQuantityParam was a public input, while DefaultQuantity is a built-in property of the Strategy base class[62]. We adopted this pattern when we needed to expose something to the UI/Analyzer that couldn’t be directly used internally without restrictions. However, this pattern is being phased out (as with DefaultQuantityParam removal) in favor of direct use of inputs. The new BaseContracts is a straightforward public int and is used directly in logic for clarity.
•	Default Values: All default values for inputs are set in OnStateChange at State.SetDefaults. This is a NinjaTrader requirement for many properties and ensures that when the strategy is added, it has a known starting configuration. For example, in SetDefaults we set toggles like UseQualityGate = false, numeric thresholds like MinQTotal2 = 0.5 (50% minimum quality), etc.[63]. Notably, we also fix DefaultQuantity = 1 in SetDefaults (and no longer expose it) to avoid confusion – position sizing is solely controlled by our BaseContracts input.
•	Validation: We use attributes like [Range(min, max)] on numeric inputs to enforce valid ranges. For example, TrendSlopeMin is [Range(0.0, 1.0)] since it’s a normalized value, BaseContracts is [Range(1, 100)] since we only allow between 1 and 100 micro contracts, etc. This prevents runtime issues from invalid values and communicates expected bounds to the user.
•	Consistent Prefixes: By convention, we prefix some params to indicate their context:
•	W_ – weight of a component in a composite (e.g., W_PosVolProxy).
•	Min/Max – bounds (e.g., MinATR, MaxATR).
•	Use – boolean toggles (e.g., UseTrendFilter).
•	...Threshold – threshold values for gating logic (e.g., RunnerMomoThreshold).
•	VP_ – volume profile related (e.g., VP_RunnerK1Param, VP_RunnerK2Param, where K1/K2 tweak runner behavior based on VP).
•	We avoid ambiguous names; each parameter’s name should reflect its role clearly, as this strategy has many moving parts.
•	Documentation: We maintain XML documentation comments for each public property (where non-obvious) to clarify their usage. For instance, explaining what MinSpaceR means (the minimum space in R multiples required for a setup to be valid) can be included as a summary on the property so it appears as a tooltip in the UI. This is ongoing – as new params are added, we update the comments accordingly.
Logging Guidelines
The strategy employs an extensive logging mechanism to record every decision and action. The following rules/conventions are used:
•	One Log Folder per Run: Upon starting the strategy (each time it’s enabled or each backtest run), a new folder is created under Documents\NinjaTrader 8\MNQRSTestLogs\ with a timestamp (RunStamp)[3][64]. All log files for that run are placed there. This ensures logs from different runs don’t mix and provides a clear audit trail for each test/trading session.
•	Log Files and Contents:
•	RunInfo.txt: Captures the configuration of the run. This includes timestamp, and every strategy parameter value at start[7][59]. For example, it will list BatchTag, all the filter toggles, threshold values, weights, and crucially the position sizing setting (DefaultQuantity or now BaseContracts). This is written once at startup.
•	Setups.csv: Logs each potential trade setup and filtering outcome. Columns include Date, Time, Event, Side, Reason, TriggerPrice, StopPrice, TargetPrice, R-value, StopTicks, Notes[6][65]. Each time the strategy evaluates an entry condition, if it decides to skip a setup due to a filter, it logs “Skip” with the reason (e.g., QualityFail, TimeFail, etc.). If it arms a setup, it logs “Armed” along with the trigger (entry) price and initial stop/target prices recorded. If an armed setup expires without triggering, it logs “Expired” with reason “Stale”. These entries are appended via LogSetupRow() whenever such events occur[8][66].
•	Trades.csv: Logs each actual entry order placed. Columns include Date, Time, Side (Long/Short), EntryPrice, StopPrice, TargetPrice, Qty, EntryName, and a snapshot of key quality metrics at that moment (Q_Total2, Q_Swing, Q_Momo, Q_Vol, Q_Session, Q_ResRunner, SpaceR, ATR, SessionWeight)[5][67]. We record one line per entry execution: for example, if a trade is split into CORE and RUNNER, there will be two lines – one for each entry signal (with EntryName “CORE” or “RUNNER”). The Qty field shows how many contracts were in that portion (e.g., CORE 1, RUNNER 1 if BaseContracts=2). Single entries use EntryName “Single”. This logging happens immediately when orders are submitted in ApplyRunnerPreset via LogTradeRow()[43][68].
•	Exits.csv: Logs each exit fill. Columns: Date, Time, Side (Long/Short corresponding to original entry direction), EntryName (which leg exited), ExitPrice, ExitType[69][70]. ExitType is a label we determine in code – “Target” if the exit price was at the planned profit target, “Stop” if at the planned stop, “Breakeven” if at entry price (for runner stops moved to breakeven), or “Manual” if none of the above (e.g., a manual close or an unexpected exit price). The strategy uses OnExecutionUpdate to catch filled exit orders and logs them via LogExit()[52][53]. This ensures even partial exits or multi-leg exits are individually recorded (e.g., both CORE and RUNNER exits will appear, each on their own line, when they occur).
•	CSV Format: All CSVs use comma-separated values with a header row established at file creation[4][71]. They are designed for easy import into Excel or analysis tools. Numeric values are formatted to a reasonable number of decimal places (e.g., prices to 2 decimals, quality metrics to 4 decimals as they are 0-1 floats[72][73]).
•	Logging Frequency and Performance: We take care to log only key events (entry decisions, actual trades, and exits). The most frequent would be Setup logs, which occur at most once per bar (and only if a signal is present or a filter triggers a skip). This has been manageable in backtests. If performance becomes a concern with high-frequency logging (e.g., running on tick data), we might introduce a toggle like ExportDuringOptimization (which exists as a flag) to disable detailed logging when doing large-scale optimizations, since file I/O can slow those down. Currently, ExportDuringOptimization can be used to turn off logging during strategy analyzer runs to speed up sweeps.
•	Thread Safety: NinjaTrader strategies run on a single thread for their own events, so writing to the files from OnBarUpdate and OnExecutionUpdate is generally safe. We still ensure that log initialization happens only once (using the logsReady flag to guard EnsureLogsInitialized() so files aren’t recreated mid-run)[74][75]. Each log write call opens, appends, and closes the file (via File.AppendAllText), which is simpler than maintaining an open file handle and avoids file lock issues. This “hard lock” approach (open-write-close per entry) is robust albeit slightly less efficient; given the low frequency of events relative to bar processing, it has not been an issue.
•	Debugging with Logs: We rely on these logs heavily to debug strategy behavior. For example, if a trade was expected but didn’t occur, the Setups.csv will likely show a “Skip” with a reason, revealing which filter blocked it. The Trades.csv combined with Exits.csv allows us to reconstruct each trade’s lifecycle (entry to exit) and verify that stops/targets behaved as expected. RunInfo.txt is crucial when comparing results from different runs to ensure we know which parameters were in effect.
Debug Print Guidance
While logs provide a permanent record, sometimes we use Print() statements for quick debugging during development:
•	Purposeful Use: Print() is used sparingly and usually guarded by conditions. For instance, in ApplyRunnerPreset we included a debug print to output the factors affecting allowRunner (runner management enabled, quantity, QRes vs threshold, QMomo vs threshold, result)[76]. This is extremely helpful when testing to see why a runner was or wasn’t allowed on a given bar. We wrap such prints in the code (they run always in the current design, but we could conditionally execute them based on a debug flag if needed).
•	Avoid Overprinting: We avoid printing inside tight loops or every bar unconditionally, as that can flood the NinjaTrader output window and slow down execution. Instead, print statements are targeted to specific events or toggled by a debug mode. For example, the ForceEntry mode (below) is effectively a debug feature to force trades – one might use it in combination with prints to observe how the strategy behaves in trade management without waiting for real signals.
•	Removal/Cleanup: Before final production deployment (Pass 20), any ad-hoc Print() used for debugging should be removed or turned off by default. They are great for development and understanding flow, but in a live running strategy, prints can cause performance overhead and clutter the log. We plan to either wrap them with a if (IsDebug) Print(...); where IsDebug is a non-[NinjaScriptProperty] bool we can toggle in code, or remove them entirely once the logic is verified.
•	Examples of Usage: Aside from the runner debug print, we might temporarily add prints in methods like OnBarUpdate to confirm values of certain metrics or flags (e.g., Print($"QTotalNew={lastQTotalNew}, gate={(UseQualityGate ? "on" : "off")}");). Typically, after diagnosing the issue, these prints are commented out or removed. We keep the codebase as clean as possible, so any committed prints should be intentional and documented.
•	NinjaTrader Output vs Logging: Note that Print() outputs to the NinjaTrader Output window, which is volatile (clears on restart and not saved). This is different from our persistent CSV logs. Use Print for transient debugging, and rely on the CSV logs for persistent records.
Position Sizing & Risk Management Handling
One of the more nuanced parts of this strategy is how it handles position sizing, given NinjaTrader’s constraints. Here are the practices and rules we follow:
•	DefaultQuantity Fixed at 1: We do not use NinjaTrader’s DefaultQuantity for dynamic sizing anymore. The strategy sets DefaultQuantity = 1 in OnStateChange(State.SetDefaults) and does not change it thereafter[63]. This is because NT8 requires DefaultQuantity to be set only during configuration, and changing it on the fly or exposing it to the UI can cause issues[60]. In earlier versions, we tried mapping a parameter to DefaultQuantity (as DefaultQuantityParam), but found it unreliable and not optimizer-friendly. The official guidance (and our experience) is: treat DefaultQuantity as a constant. We use our own BaseContracts parameter to control sizing instead.
•	BaseContracts Input: This is now the single source of truth for how many contracts to trade per entry. It’s an integer, 1 to 100 (default might be set to 2 for initial testing to allow runner logic, but user can choose 1 for single-contract mode). BaseContracts effectively replaces what a user would normally set as “quantity” on the strategy dialog. By making it a normal strategy parameter, we allow the Strategy Analyzer to optimize it if desired (e.g., test performance with 1 vs 2 vs 3 contracts, etc.). It also simplifies logic because we can reference BaseContracts anywhere in code without the special constraints of DefaultQuantity.
•	Entering Trades with Quantity: With the introduction of BaseContracts, all entry methods are being updated to use the overload that specifies quantity. For example, EnterLong("Single") becomes EnterLong(BaseContracts, "Single") to submit the desired number of contracts. In split trades, we calculate coreQty and runnerQty based on BaseContracts. Currently, the logic does:
•	qty = BaseContracts (with a safety Math.Max(1, BaseContracts) to avoid 0) – this is the total intended position size[77].
•	If splitting into CORE/RUNNER, runnerQty = Math.Max(1, qty/2) and coreQty = Math.Max(1, qty - runnerQty)[39]. This roughly splits in half, favoring the core (e.g., 3 contracts -> core 2, runner 1). In the future we might make the split ratio configurable, but for now it’s fixed 50%.
•	If not splitting (no runner), then we treat the whole qty as one “Single” position[38].
•	Then we call the appropriate Enter… method with those quantities. Important: NinjaTrader will ignore our quantity parameter if we mistakenly also set the strategy’s default quantity in the UI. By fixing DefaultQuantity=1 and removing it from UI, we ensure our specified quantities take effect. (NT uses DefaultQuantity only if you call parameterless EnterLong(); if you call EnterLong(int qty), it uses that qty.)
•	Risk Calculation (R): The strategy computes a risk unit “1R” for each trade based on recent bar range. We set stop and target at 1R distance by default. Specifically, we calculate risk = Max(currentBarRange, MinAbsSpaceTicks * tickSize)[78]. This ensures at minimum we consider at least MinAbsSpaceTicks ticks as risk (so we’re never assuming zero risk on tiny bars). The stop price for a long is entry – risk, target is entry + risk (vice versa for shorts)[79]. This approach fixes the initial stop/target for the core position. We might incorporate ATR or other volatility measures into risk in the future, but currently it’s tied to the signal bar range.
•	Runner vs Core Sizing: The logic requiring BaseContracts >= 2 to allow a runner ensures that if only 1 contract is traded, we don’t attempt to split (you can’t split 1 contract)[34]. When exactly 2 contracts, core and runner will be 1 each (50/50). For larger even numbers, it’s equal split; for odd, the core gets the extra contract. This also means the CORE profit target essentially secures at least half the position at +1R, locking in profit, while the RUNNER has no profit target and will only exit at breakeven or via manual intervention (in our case, currently, we don’t have a trailing stop beyond breakeven – implementing a trailing logic or exit signal for the runner could be a future improvement).
•	Scaling and Partial Fills: We do not dynamically scale in or out beyond the initial split. Once the trade is entered, we have two (or one) legs and we let them be managed by their stops/targets. The strategy doesn’t currently adjust position size during the trade (though lastRunnerPct adjustments are computed when UseVPRunnerScaling is on, we don’t have a mechanism to act on them mid-trade due to NT limitations without adding new orders). All exits are passive (driven by the orders placed at entry or manual close). NinjaTrader will handle partial fills if, say, only some contracts get filled initially (though for micros this is typically not an issue).
•	DefaultQuantityParam Removal: It’s worth reinforcing why we removed DefaultQuantityParam. In prior code, we had:
 	[Display(Name = "DefaultQuantity", GroupName = "Position Settings", Order = 2)]
public int DefaultQuantityParam { get; set; }
...
DefaultQuantityParam = 2;
DefaultQuantity = DefaultQuantityParam;  // safe here
 	This allowed the analyzer to vary DefaultQuantityParam[61], and we mapped it to the actual DefaultQuantity. However, if a user changed the strategy’s quantity via the UI (which sets DefaultQuantity), it could desync from our param. Also, NT’s Strategy Analyzer doesn’t include DefaultQuantity in optimization by default, leading to confusion. By dropping this and using BaseContracts, we avoid all that. We no longer care what NT thinks the “default quantity” is – it’s always 1 internally – we drive sizing purely through our logic.
•	Risk Management Beyond Stops: Currently, the fixed 1R stop for the core and breakeven stop for runner is our risk management approach. We ensure that every trade has a stop placed immediately (using SetStopLoss as soon as we enter) so there is always a protective stop in the market. We don’t yet implement position-based risk calculations like “risk X% of account per trade” – since this is a futures micro contract strategy, position size is more discretely controlled via BaseContracts. The user can indirectly risk more by increasing contracts. If account-risk-based sizing is needed in future, one could calculate BaseContracts dynamically in OnBarUpdate based on account size and stop distance, but note NinjaTrader doesn’t support changing quantity mid-run – it would have to be an input that gets recalculated and possibly the strategy restarted or run on each trade separately via an external manager.
•	Handling Errors: One quirk discovered was that leaving DefaultQuantityParam “unwired” (e.g., if we forgot to set DefaultQuantity = DefaultQuantityParam or if DefaultQuantityParam was null in some context) could lead to null reference errors or trades not triggering. The new approach sidesteps this entire class of errors. Now our quantity is a normal C# int property, always initialized to a valid value, and directly used. This should eliminate the null-reference issues we saw (which were due to NinjaTrader’s internal handling of DefaultQuantity in some cases).
In summary, the strategy’s sizing is now explicit and under our control. Always use BaseContracts for any logic that needs to know how many units we are trading. When coding entries or calculations, do not rely on this.DefaultQuantity except for the initial split logic which currently still references it (to be replaced by BaseContracts in Pass 16.5). After that update, we expect all references to DefaultQuantity to disappear except the one line setting it to 1.
Entry Logic Control Flow
The entry logic in MNQRSTest has multiple stages and optional bypasses. Understanding the flow is crucial for extending or debugging the strategy:
•	ForceEntry Mode (Debug Bypass): At the very top of OnBarUpdate, we implemented a debug override called ForceEntry. If ForceEntry == true and the strategy is currently flat (no open position), the strategy will bypass all normal entry criteria and immediately submit an entry on each bar[80]. This entry’s direction is chosen based on the bar’s direction (up-bar = Long, down-bar = Short) for variety[81][82]. We call EnsureSplitSizingReady() and then ApplyRunnerPreset(isLong) to execute the trade[82]. This mode is extremely useful for smoke-testing the order submission, sizing, and exit logic in a controlled way – it basically forces a trade every bar so you can quickly generate many trades. When ForceEntry is on, none of the quality metrics or filters are evaluated (we return early after submitting the order)[83]. By default, ForceEntry is false and it should remain false in normal operation[84].
•	Pre-Entry Safety Checks: After handling ForceEntry and ensuring the primary series (BarsInProgress == 0) and sufficient bars loaded (CurrentBar >= 1), we do a quick safety check that our indicators are initialized[1]. If for some reason, e.g., priceEma or atrIndicator is null (perhaps indicator failed to load), we return without doing anything[1]. This avoids null usage in calculations.
•	Metric Calculations: We then compute all the context metrics in a set sequence each bar:
•	ComputeBaseQualityMetrics() – (Details not fully shown above, but presumably calculates baseline factors like trend strength, etc.)
•	UpdatePosVolInputs() – updates volume-based directional bias metrics[13][14].
•	MomentumCore_Update() – calculates lastQMomoCore (momentum core) and we then update momentum “families” via MomoFamilies_Update(Q_Space, Q_Trend) (likely to compute composite momentum metrics, though exact details not shown here)[11][12].
•	ComputeQualityScores() – combines the metrics into lastQTotalOld and lastQTotalNew (the composite quality scores)[15][16].
•	Additional metrics like Q_Swing, Q_Momo (raw), Q_Vol, Q_Session are computed and stored (as part of Pass 9)[85][86].
•	If UseVolumeProfile is enabled, call UpdateVPContext() to fetch volume profile signals (in current version, this just zeroes out or sets neutral values)[48].
These steps prepare all the information needed to make an entry decision. They happen every bar, regardless of whether a trade will occur, when the strategy is flat.
•	Generating Entry Signals: The strategy’s actual signal generation is handled in a method UpdateEntrySignals() (not shown in excerpt, but mentioned). This would set flags like entryLongSignal or entryShortSignal (or similar) based on conditions (e.g., a moving average crossover, or threshold conditions on the quality metrics). In our case, one key signal is the detection of a “crossUp” or “crossDown” (likely price crossing above/below an EMA or some momentum indicator crossing) as seen in the filter code snippet[87][88]. UpdateEntrySignals() would set something like crossUp = true or crossDown = true when those conditions occur on the current bar. It might also arm breakout setups directly in some cases, but our design separates it: signals trigger setup arming in the next step.
•	Entry Filters: Before arming a trade, we apply the entry filters (if enabled) to the current bar’s signal:
•	Quality Gate: if UseQualityGate and lastQTotalNew < MinQTotal2, then we do not allow a setup[89] (in that snippet, allowSetup = false if quality fails).
•	Time filter: if !IsWithinEntryTime(), disallow (outside trading hours)[90].
•	Volatility filter: if !IsVolatilityOk() (ATR-based check), disallow[91].
•	Trend filter: if a long signal and !IsTrendOk(true) or short and !IsTrendOk(false), disallow[92]. These checks are done in sequence; each failing condition logs a “Skip” in setups (the code in the excerpt was simplified, but our actual implementation calls LogSetupRow("Skip", side, "Reason", ...) for each filter fail as seen in earlier references[8][10]). We accumulate an allowSetup flag through these filters.
•	Arming the Trade: If allowSetup remains true after all filters, we proceed to arm a breakout trade:
•	If we had a long signal (crossUp true, for example), we set setupArmed = true, setupIsLong = true, and record the current bar’s high as setupHigh and low as setupLow[93]. We reset setupBarsAgo = 0. Then log Armed in Setups.csv with the trigger and stop reference prices[94]. We do similarly for a short signal (arm with setupIsLong = false and record the values)[95]. After arming, we do not place an order yet; we return and wait for the next bar.
•	If no setup was allowed or no signal, nothing is armed and the strategy just waits.
•	Breakout Trigger: On the next bar (and subsequent bars until it either triggers or expires), at the top of OnBarUpdate, we check if Position is flat and a setupArmed is true[96]. If so, we compute the breakout price = previous setup bar’s high + one tick (for long) or low – one tick (for short)[97][98]. If the current bar’s price exceeds that level (e.g., current High > breakoutPrice for a long), that means the breakout occurred. We then:
•	Call EnsureSplitSizingReady(), which prepares runner split percentages if applicable (it sets lastRunnerPct based on whether we have 2+ contracts and runner management on)[99][100].
•	Call ApplyRunnerPreset(isLong) to actually place the orders[101][102]. This method handles deciding single vs core/runner, placing the orders and stops, and logging the trade entries as described earlier.
•	Set setupArmed = false because the setup is now executed (and we don’t want to retrigger it).
•	If the breakout price is not hit on that bar, we increment setupBarsAgo++. If setupBarsAgo exceeds a small limit (we use 3 bars currently), we consider the setup stale and give up, setting setupArmed = false and logging an “Expired” event[103]. This prevents hanging orders from a setup that never broke out.
•	In-Trade Management: Once a trade is entered, the strategy’s position is non-flat. We skip the entry signal logic when Position.MarketPosition != Flat. Instead, we focus on managing the open trade:
•	We utilize NinjaTrader’s managed order framework (the SetStopLoss and SetProfitTarget we set when entering) to automatically handle core exits. The runner’s stop is set to breakeven at entry.
•	Each bar in a trade, we call ApplyVPManagementAdjustments() (if enabled) to adjust internal lastRunnerPct as discussed, although currently this doesn’t translate to an action on the active trade (more of a placeholder for potential future dynamic exits)[104][56].
•	We monitor for exit fills via OnExecutionUpdate to log them. We do not send new orders while in a trade (no scale-in or scale-out beyond the initial split).
•	The position will eventually exit either by hitting the stop or target (for core) or stop at breakeven (for runner). When flat again, the entry logic resets and we start looking for new setups on subsequent bars.
•	ApplyRunnerPreset Details: It’s helpful to note what ApplyRunnerPreset does internally:
•	It determines allowRunner (as per thresholds and BaseContracts count)[36].
•	It prints out debug info about runner eligibility (factors and result)[76] – useful for understanding entry decisions.
•	It calculates qty = BaseContracts (or DefaultQuantity in older code)[105].
•	It computes stopPrice/targetPrice = entry ± risk (1R)[106].
•	If runner allowed, it splits qty into coreQty and runnerQty[39], sets up two stop losses (one for CORE at full 1R, one for RUNNER at breakeven)[41], sets profit target for CORE[41], and sends EnterLong/Short for each part with signal names.
•	If runner not allowed, it submits a single EnterLong/Short for full qty with a stop at 1R and target at 1R[38].
•	It logs the trade entries via LogTradeRow calls immediately after submitting orders[43][68].
•	Order Naming Convention: We name our entry orders with signals “CORE”, “RUNNER”, or “Single” to identify them. This is important because our exit logging logic checks execution.Order.FromEntrySignal against these names to decide if an execution is an exit fill[107][108]. For example, if we get an execution update and FromEntrySignal is “CORE” but the actual Order.Name is “Profit target” (NinjaTrader’s internal name for the generated exit order), we know this is an exit of the CORE position (because the exit’s FromEntrySignal points to the CORE entry). The naming also helps in logs to match which part of the trade the exit belongs to.
•	Smoke Testing with ForceEntry: When modifying entry logic, a quick way to test is enabling ForceEntry = true on a historical test – the strategy will take a trade every bar, so you can generate many Trades/Exits log lines in a short time. This can expose issues with order handling, mismatches in quantities, or logging errors very quickly. Just remember to turn it off for real usage!
•	Filters vs Signals: We have structured things such that filters do not generate signals, they only block signals. The actual trade triggers come from the core logic (momentum/quality cross etc.), and filters like quality gate, ATR, time, trend simply prevent arming if conditions aren’t met. This modular approach means adding/removing filters is easy and doesn’t entangle the signal logic. For example, one can disable UseQualityGate and the strategy will take trades regardless of quality score (useful for baseline comparison), or disable UseVolatilityFilter to allow trades in all volatility regimes, etc., without needing to rewrite the signal conditions.
By following this flow, one can trace through any given bar: calculate metrics → check signals → apply filters → arm trade → trigger breakout → manage trade. Each stage has logging to indicate what happened. When extending or debugging, it’s important to preserve this structure – e.g., if adding a new filter, integrate it in the filter section with proper logging; if adding a new entry setup type, ensure it logs an “Armed” event and triggers similarly.
