Development Roadmap (Pass 1 – 20+)
Below is a high-level roadmap of the iterative development “passes” for the MNQRSTest strategy. Each pass introduced or refined key features. (We are currently around Pass 16, with Pass 16.5 in progress.)
1.	Pass 1: Initial Strategy Scaffold – Set up the NinjaTrader 8 strategy structure as a partial class, with basic OnBarUpdate and OnStateChange methods. Established a single-entry prototype (e.g. basic EnterLong() on a simple condition) to verify the strategy wiring. No advanced logic – just a “Hello World” trade to ensure the strategy runs. Logging framework concept defined (files for trades, etc.) but not fully implemented.
2.	Pass 2: Core Indicators & Prep Work – Integrated foundational indicators and data series needed for later logic. For example, added an EMA for price, ATR for volatility, RSI and ADX for future use, etc., and began tracking basic market metrics. Ensured these were initialized in OnStateChange (State.DataLoaded) and available for use[1][2]. This pass laid the groundwork for computing “quality metrics” by having price trend and volatility measures ready.
3.	Pass 3: Basic Quality Metrics and Signals – Introduced the concept of quality metrics for trade setups. Implemented preliminary calculations like space (available movement range) and trend slope as simple measures (e.g., slope of price EMA) to gauge trade quality. Early gating logic was added: trades would only trigger if certain conditions met minimum thresholds. Initial boolean flags for enabling/disabling filters were introduced (e.g. UseQualityGate, time filters), though the thresholds were rudimentary at this stage.
4.	Pass 4: Logging System Implementation – Built out the structured logging framework for debugging and analysis. Created the EnsureLogsInitialized() method to generate a new timestamped folder per run and create log files: Trades.csv, Setups.csv, Exits.csv, and RunInfo.txt[3][4]. Wrote headers for each CSV (e.g. Trades log columns include date, time, side, prices, quantity, quality metrics, etc.[5]; Setups log includes event type, reason for skip, etc.[6]). RunInfo.txt captures the parameter settings of the run[7]. Basic logging calls (LogTradeRow, LogSetupRow, LogExit) were created to append events to these files as trades progressed.
5.	Pass 5: Initial Entry Filters & Quality Gate – Added the first layer of entry decision filters. This included a Quality Gate using an aggregate quality score: if the computed quality (then just a simple average of a few factors) was below a minimum (MinQTotal2), the setup was skipped[8]. Also introduced time window filters (via UseEntryTimeFilter, start/end hours) to restrict trading to certain hours, a volatility filter using ATR (UseVolatilityFilter, with MinATR/MaxATR bounds), and a trend filter requiring a minimum EMA slope (UseTrendFilter, TrendSlopeMin). These filters were applied just before arming a setup; any failure would log a “Skip” in Setups.csv with reason (e.g. “QualityFail”, “TimeFail”, “VolFail”, “TrendFail”)[9][10]. By the end of Pass 5, the strategy would only arm trades when all enabled filters passed.
6.	Pass 6: Momentum Core Metric Introduction – Implemented the Momentum Core concept to gauge market momentum in a more robust way. A new internal metric lastQMomoCore was computed each bar via MomentumCore_Update(), and momentum “families” were considered (e.g. ROC, TSI, MACD, Efficiency Ratio, streaks) for possible inclusion[11][12]. This pass primarily set up the structure to calculate and store momentum-related quality measures (with placeholders for multiple momentum sub-indicators). The momentum core would later influence both entries and runner trade management.
7.	Pass 7: Positional Volume Metrics (PosVol) – Added positional volume context metrics to incorporate volume dynamics into trade quality. This included measuring buy vs sell volume in each bar and smoothing it to derive a positional volume bias. New functions like UpdatePosVolInputs() were introduced to compute a proxy quality Q_PosVol (later lastQ_PosVol_Proxy) representing the strength of buying vs selling pressure[13][14]. This metric was blended with existing factors to enhance the quality score. (At this stage, these volume metrics were experimental and weighted via a parameter W_PosVolProxy to allow turning their influence up/down.)
8.	Pass 8: Composite Quality Score & Gate Refinement – Refined how the various quality components combined. Implemented ComputeQualityScores() to calculate two composite scores: an “old” score (legacy factors like space, trend, etc.) and a “new” score incorporating the new positional volume proxy[15][16]. The quality gate was updated to use lastQTotalNew (the new composite) with a configurable threshold MinQTotal2. This ensured that if positional volume or other new factors were in play, they influenced the pass/fail of a trade setup. The logging was adjusted so that Setups.csv would record “QualityFail” if lastQTotalNew < MinQTotal2. By end of Pass 8, the strategy had a more robust composite quality gating system.
9.	Pass 9: Quality Metrics Expansion – Introduced additional quality sub-metrics to further characterize market state[17][18]. Specifically: Q_Swing (measuring swing momentum via the slope of the price EMA, normalised)[17], Q_Momo (exposed the raw momentum core measure as its own metric)[19], Q_Vol (normalized ATR for volatility)[20], and Q_Session (time-of-day/session weighting). These were computed each bar and fed into the composite quality score. The code comments explicitly mark this as “Pass 9”[18]. This expansion gave a richer view of trade quality, though initially without additional gating (the factors were blended into the overall quality score rather than each having individual thresholds).
10.	Pass 10: Space/Resistance Gating – Implemented space & resistance checks to ensure trades have room to move. This pass added the CheckSpaceAndResistance() routine, which examines recent price action to determine the distance from the current price to a recent high/low (for long/short respectively) relative to the risk (1R) of the trade[21][22]. This distance is computed as spaceR (space in R multiples). If spaceR is below a minimum threshold (MinSpaceR), the setup is skipped as “SpaceFail”[23][24]. In effect, a trade is only armed if there is at least ~1R of “space” before hitting a likely support/resistance from the past N bars. This feature was noted as Pass 10 in code comments[25]. (The term resistance is used loosely – essentially this is a minimum favorable excursion requirement.)
11.	Pass 11: Breakout Entry Logic & Setup Arming – Enhanced the entry signal logic to use a breakout-based entry mechanism. Rather than entering immediately on a signal bar, the strategy now “arms” a setup at one bar and then enters on a break of that bar’s high/low on the next bar. Concretely, when a long signal is detected (e.g., a bullish cross), the strategy records the high of that bar and sets setupArmed = true for a long[26]. On the subsequent bars, if price exceeds that high by 1 tick, it triggers ApplyRunnerPreset(true) to enter the trade[27]. Similarly for shorts with the low[27][28]. If a breakout doesn’t occur within a few bars (currently 3 bars), the armed setup expires (logged as “Expired/Stale”)[29]. This pass significantly improved trade entries by ensuring momentum confirmation. It also formalized the UpdateEntrySignals vs OrderTrigger separation: first identify a potential setup, arm it, then trigger actual orders only on validation (breakout). By end of Pass 11, Setups.csv logging captured “Armed” events with recorded trigger levels[30][31] and “Expired” events for lapsed setups[29].
12.	Pass 12: Runner Management Framework – Introduced the concept of splitting a position into CORE and RUNNER components for exit management. This pass created the ApplyRunnerManagement toggle (off by default) and laid out the logic for multi-part positions. If runner management is enabled and the position size allows (see Pass 13), the strategy will allocate two exit strategies: a core position with a fixed profit target (e.g., 1R) and a runner position with no profit target (to let profits run)[32][33]. In this pass the split was implemented conceptually but actual order placement was likely still single-lot (the groundwork was set, but quantity handling came later). Also, groundwork for volume-profile-based management was placed: placeholders like UseVPTrailSwitch, UseVPRunnerScaling, and params VP_RunnerK1/K2, etc., were defined (but their logic would come later). Essentially, Pass 12 set the stage for advanced exit management by introducing the idea of two-tier position exits.
13.	Pass 13: Runner Eligibility & Thresholds – Built on the runner framework by adding eligibility checks and thresholds for splitting trades. Two new parameters were introduced: RunnerMomoThreshold and RunnerSpaceThreshold (both defaulting to 0.0 initially) to gate whether a given trade’s conditions justify using a runner leg[34][35]. In ApplyRunnerPreset, the code now checks: runner management is on and the DefaultQuantity (position size) is ≥ 2 and the momentum core lastQMomoCore ≥ threshold and the space metric lastQRes ≥ threshold[36][35]. Only if all conditions are true, allowRunner remains true and the trade is split into Core/Runner; otherwise, the trade is taken as a single position with a normal stop/target[37][38]. This made runner usage selective – e.g., perhaps only used in high-quality momentum scenarios. Also, this pass refined the actual order placement logic: calculating a 1R risk from bar range, setting stops and targets accordingly, and if splitting, computing coreQty and runnerQty (roughly 50/50)[39][40]. The CORE order is submitted with a stop loss at –1R and profit target at +1R, while the RUNNER order is submitted with a stop at breakeven and no profit target[41][42]. Logging was updated to record each part: e.g., a CORE entry is logged with its entry, stop, and target, and a RUNNER entry logged with entry and stop (target is left NaN/blank to indicate no fixed target)[43][44]. By the end of Pass 13, the multi-contract logic was functionally in place for scenarios where at least 2 contracts are available and conditions merit a runner.
14.	Pass 14: Volume Profile Context Integration – Brought in Volume Profile (VP) context as an additional layer of information for trade management. Introduced a UseVolumeProfile toggle and an UpdateVPContext() method that (in stub form) initializes profile-based signals[45][46]. In this pass, the VP context update doesn’t yet use an external indicator – it simply zeroes out placeholders for tailwind, headwind, cushion, and congestion signals[45][47]. However, the structure is ready: on each bar, after computing other quality metrics, if UseVolumeProfile is true, the strategy calls UpdateVPContext() to fetch the latest VP signals[48][49]. Although the signals are dummy at this stage, this ensures the code is “VP-ready” for when a proper volume profile indicator (like the custom QVP) is integrated in a later pass. The presence of lastQ_VP_Tailwind, lastQ_VP_Headwind, etc., also allowed future logging or adjustments based on these values (which remained zero for now). Essentially, Pass 14 prepared the strategy to incorporate market structure information (support/resistance from volume at price) into its decision-making down the line.
15.	Pass 15: In-Trade Adjustments & Logging Enhancements – Focused on improving runtime trade management and data capture. The OnExecutionUpdate override was implemented to log exits in real-time[50][51]. Whenever an exit order fills (stop loss, profit target, or manual exit), the code now detects it and logs an entry to Exits.csv with the side, which entry (CORE, RUNNER, or Single), price, and exit type (determined by comparing fill price to the planned stop/target)[52][53]. This ensures every exit (stop out, target hit, breakeven, etc.) is recorded for analysis. Also in this pass, in-trade volume profile adjustments were introduced via ApplyVPManagementAdjustments()[54][55]. If UseVPRunnerScaling is enabled (along with UseVolumeProfile), each bar while in a trade will nudge the lastRunnerPct (the fraction of the position to allocate to the runner) up or down by a small amount based on VP tailwind vs headwind[56][57]. The adjustment uses two small coefficients (VP_RunnerK1Param and VP_RunnerK2Param) and is capped at ±0.2 per bar to avoid drastic swings. (This is a subtle “experimental” feature – effectively adjusting an internal value that could be used if dynamic position resizing were allowed. In practice, with NinjaTrader not supporting changing the quantity post-entry, this mainly serves as an insight metric or would require future enhancement to act on the next trade.) Additionally, RunInfo.txt logging was expanded to include all new parameters (e.g., whether volume profile and runner management were on, what thresholds were set, etc.)[58][59] for complete run documentation. By the end of Pass 15, the strategy had comprehensive logging of setups, entries, and exits, and a mechanism (albeit limited by platform) to adjust strategy behavior mid-trade using volume profile data.
16.	Pass 16: Position Sizing Overhaul (BaseContracts) – This pass addressed the critical position sizing issue in NinjaTrader. Originally, the strategy used DefaultQuantity via a custom parameter DefaultQuantityParam to allow optimizing trade size. We discovered that relying on NinjaTrader’s DefaultQuantity was problematic: it can only be set in OnStateChange at startup and isn’t exposed as a normal input for the Strategy Analyzer to sweep[60]. Our initial workaround was to create a public int DefaultQuantityParam (with [NinjaScriptProperty]) and map it to DefaultQuantity in State.SetDefaults, so it appeared in the UI[61]. This allowed optimization, but it introduced bugs – e.g., if not wired exactly right, the strategy would sometimes see a mismatch or null for DefaultQuantity, causing logic errors. After encountering null reference errors and inconsistent behavior due to this “unwired” param hack, we decided to remove DefaultQuantityParam entirely in favor of a dedicated sizing input.
 	BaseContracts was introduced as the new position size parameter (int, allowed range 1–100). This param represents the number of micro contracts to trade on each entry. We fixed DefaultQuantity at 1 (the only safe value) and now plan to pass BaseContracts to all entry methods explicitly. In Pass 16, the BaseContracts property was added and is used for internal checks (e.g. runner eligibility now checks BaseContracts >= 2 instead of DefaultQuantity) – ensuring that a runner split is only attempted when at least 2 contracts are to be traded. However, at this stage the entry order calls (EnterLong/EnterShort) have not yet been updated to use the BaseContracts value, meaning trades are still executing a single contract by default. In other words, the infrastructure for custom sizing is in place (no more reliance on NT8 DefaultQuantity quirks), but the actual orders need to be wired to use it (that’s Pass 16.5). Pass 16 thus cleaned up the sizing code (removing the faulty DefaultQuantityParam input, preventing the Strategy Analyzer from misusing DefaultQuantity) and prepared the strategy to handle arbitrary contract quantities going forward.
16.5. (Interim) BaseContracts Order Wiring – – In Progress – This is the current development focus. The task here is to wire the BaseContracts parameter into all entry methods so that the strategy actually trades the intended number of contracts. This involves modifying ApplyRunnerPreset and any direct EnterLong/Short calls to use the provided quantity. For example, in the CORE/RUNNER logic, where we currently do EnterLong(coreQty, "CORE") etc., we must ensure coreQty + runnerQty = BaseContracts (with rounding) and for single positions call EnterLong(BaseContracts, "Single") instead of relying on the default[38]. Additionally, the ForceEntry debug path (which auto-enters a trade each bar when enabled) should be updated to call ApplyRunnerPreset in a way that includes the size. Right now, ForceEntry sets up a trade but since BaseContracts isn’t passed, it ends up entering 1 contract. After this wiring, using ForceEntry for smoke tests will exercise multi-contract entries as well.
1.	Pass 17 (Planned): Sizing Validation & Multi-Contract Testing – After wiring up BaseContracts, this pass will thoroughly test multi-contract behavior. It will involve running the strategy with various BaseContracts values to confirm that:
o	The CORE and RUNNER quantities correctly split (e.g., for an odd number like 3, we expect core=2, runner=1).
o	The Trades.csv log now accurately records the Qty as the number of contracts for each entry part (which it will, since we log the quantity we send to EnterLong/Short[43]).
o	The strategy behaves correctly when BaseContracts = 1 (i.e., always single positions, no runner) versus BaseContracts >= 2.
o	No residual references to DefaultQuantityParam or unintended behavior remain. Essentially, Pass 17 is about validation and bugfixing for the new sizing approach, ensuring that the strategy’s logic (especially runner management) works as intended with arbitrary position sizes.
2.	Pass 18 (Planned): Full Volume Profile Integration – With core strategy logic solid, the plan is to integrate a real volume profile indicator to replace the stub in UpdateVPContext(). In this pass, we aim to feed actual tailwind/headwind signals based on volume at price. For example, using a custom QVP (Quantity Volume Profile) indicator or NinjaTrader’s Order Flow Volume Profile to measure if current price is in a high-volume node (potential support/resistance) or low-volume area (potential quick move). The values lastQ_VP_Tailwind, Headwind, Cushion will be set to meaningful numbers (e.g., between 0 and 1 representing favorable vs unfavorable structure). These VP signals could then be incorporated into entry filters (for example, avoiding entries into heavy headwind) or into in-trade management. We will also consider implementing trail-stop switching (“VPTrailSwitch”) where, if certain conditions are met, the runner’s stop might trail using volume profile levels. Pass 18 will likely produce a more adaptive strategy that can react to market structure, and any new logic will be reflected in logs (e.g., possibly logging VP-related metrics per trade for analysis).
3.	Pass 19 (Planned): Optimization and Parameter Tuning – With all major components in place (momentum, posVol, filters, runner, VP, sizing), this pass will focus on optimizing the strategy parameters and cleaning up the configuration. We will use NinjaTrader’s Strategy Analyzer (backtest and optimization) to sweep through key parameters: e.g., quality thresholds, momentum/space runner thresholds, and possibly discover ideal weightings for the composite score factors (W_QSwing, W_QVol, etc.). Because BaseContracts is now a standard [NinjaScriptProperty], we can also optimize position size to see scalability of the strategy. We’ll ensure the BatchTag presets (if any) are up-to-date or remove them if not needed. Logging may be adjusted to reduce noise or only output on significant events if performance becomes a concern. The outcome of Pass 19 should be a tuned set of default parameters and a clear understanding of which filters or components add the most value.
4.	Pass 20 (Planned): Final Refactoring and Hardening – The final planned pass is about polish and robustness. We will audit the code for any inefficiencies or NinjaTrader idiosyncrasies that might cause issues in live trading (for example, ensuring all file I/O in logging is properly guarded – currently each log write opens the file, which is safe in NT’s single-threaded strategy context, but we will double-check thread-safety in OnExecutionUpdate logging). We will remove or #ifdef out extraneous Print debug statements used during development to keep the output clean. Exception handling will be reviewed – e.g., making sure any potential indicator errors or math edge cases are caught so the strategy doesn’t error out during live runs. We’ll also update documentation (comments, parameter descriptions) for clarity. The strategy should be ready for forward testing on live or simulated data after this pass.
(Beyond Pass 20, further enhancements could include things like machine-learning-based signal refinements, multi-timeframe inputs, etc., but those are outside the current scope.)
Current Roadmap Status: We are currently mid-way through the sizing overhaul (Pass 16.5). Most foundational features are completed (passes 1–15), runner logic is in place but awaiting the final sizing fix. The next immediate step (Pass 16.5) is critical to unlock multi-contract trading in this micro NASDAQ strategy.
