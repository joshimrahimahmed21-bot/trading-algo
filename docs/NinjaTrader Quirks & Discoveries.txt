NinjaTrader Quirks & Discoveries
During development, we encountered several NinjaTrader-specific quirks. These are important to note as they explain some of our design decisions and warn future developers:
•	Dynamic DefaultQuantity Limitation: NinjaTrader 8’s Strategy.DefaultQuantity cannot be changed or accessed dynamically in the way normal C# properties can. It is only meant to be set in State.SetDefaults or State.Configure and thereafter remains fixed[60]. If you attempt to modify it during strategy runtime, it either does nothing or can cause instability. Additionally, DefaultQuantity is not included as a tunable parameter in the Strategy Analyzer optimization by default (since it’s not a [NinjaScriptProperty]). These limitations forced us to abandon using DefaultQuantity for controlling trade size. Instead, we followed the NinjaTrader support guidance of using our own input variable for order quantities[110] – hence the creation of BaseContracts. (In summary: treat DefaultQuantity as a static default; use custom params for any dynamic or optimizable sizing.)
•	Strategy Analyzer and Quantity: As noted, the Strategy Analyzer UI will not list DefaultQuantity for optimization. Initially, our workaround (DefaultQuantityParam) made it appear, but this was kludgy. One issue we found is that even if you expose a param and set DefaultQuantity from it, the Strategy Analyzer’s internal handling could still use the original DefaultQuantity in certain cases (especially if the strategy is re-enabled manually with a different quantity). This could lead to confusion where backtest results didn’t match expected quantities. Using BaseContracts now, we completely bypass that – Strategy Analyzer treats it like any other int input (we can optimize it over 1–X range), and we always call EnterLong(x) with that value, so what you see is what you get in backtests.
•	Partial Fills and Order Names: NinjaTrader sometimes can split order fills (especially in live trading). For example, an order for 2 contracts might fill in 2 lots of 1. Our OnExecutionUpdate is robust to that – it doesn’t log an exit until the entire order is filled and identified as an exit by comparing names/signals[107][111]. We discovered that using the FromEntrySignal is the best way to tag exits to their entry. The quirk is that NT will name exit orders like “Profit target” or “Stop loss”, and those names won’t match the entry signal name. We leverage that: if execution.Order.Name != entryName then it’s an exit fill[51]. This is a NinjaTrader detail – understanding how NT names orders (and that FromEntrySignal connects them) was key to getting our exit logging right.
•	Managed Orders and Unmanaged Consideration: We used exclusively Managed orders (the high-level SetStopLoss, EnterLong, etc.). NinjaTrader’s Managed mode has certain constraints (e.g., you can’t submit an exit before an entry, you can’t have two competing orders on the same side, etc.). We had to structure our logic within those rules. For instance, we do not submit any entry if we’re already in a position (prevents violation of the internal order handling rules). We also ensure to cancel setupArmed when an order triggers or after a few bars to avoid lingering signals. A discovery was that if we didn’t cancel an armed setup and an opposite signal came, the strategy could try to arm a new trade while one was technically still armed – leading to confusion or ignored orders. We added logic to clear setupArmed after a max number of bars or when an opposite signal appears (not explicitly shown above, but it’s considered). The takeaway: always abide by NT’s managed order sequence requirements to avoid rejected orders.
•	Backtest vs Real-time Differences: NinjaTrader’s Simulator vs Real-time can behave a bit differently especially with intrabar order triggers. Because we submit breakout entries on the same bar when the condition is met (using High[0] > breakoutPrice in OnBarUpdate), in backtest this is evaluated with bar’s final data (since we use Calculate.OnBarClose by default). In real-time, if running OnBarClose, it would also effectively trigger only after the close of the bar that exceeded the level. If more granularity is needed (entering exactly when price crosses intra-bar), we’d need to use either Calculate.OnPriceChange or a secondary tick data series. For now, our approach is coarse (bar-based). We note this as a “quirk” because it means the strategy might get in a tick or a bar later than an ideal scenario. It’s a design choice influenced by how NT’s backtest engine works. In future, if precision entry is needed, we might incorporate a 1-tick secondary series to trigger entries the moment the level is touched. But adding that comes with complexity in backtesting vs optimization performance.
•	Unrealized PnL and Indicator Resets: Not directly covered in our logic, but worth noting: NinjaTrader resets strategy values when you disable/enable a strategy. We must ensure any static-like caches or singletons are re-initialized. Our strategy avoids static state for this reason. We rely on NinjaTrader’s built-in states (SetDefaults, DataLoaded, etc.) to init all variables fresh each run. Also, NT does not automatically carry over unrealized PnL between sessions for strategies – each backtest or enable starts flat unless we code otherwise. Our strategy always assumes flat start (which is fine for our use-case).
•	Garbage in UI after Removing Param: After removing DefaultQuantityParam, if you had the strategy saved with that param in a workspace, NinjaTrader might throw an error on load or keep a stale value. The solution we found is to remove and re-add the strategy to a chart or template to clear out old param entries. This is just something to be mindful of when renaming or removing public properties – NinjaTrader doesn’t like missing properties on reload. In development, when we make such changes, we test by re-importing the script or restarting NT8 and adding the strategy fresh.
Overall, the key NinjaTrader takeaways are: Keep DefaultQuantity at 1 (don’t mess with it at runtime), use custom inputs for anything dynamic, and be mindful of how NT’s managed order system processes entries/exits, especially regarding names and states, to align our code accordingly. Many of our adjustments (like logging design and order handling) were informed by these platform specifics.
Next Steps (Pass 16.5 Recommendation)
For continuity, the very next development step is to finalize the BaseContracts integration and ensure the strategy fully supports multi-contract trading. Here’s the plan for Pass 16.5:
•	Wire BaseContracts into Entries: Go through all places where orders are placed and replace parameterless calls with quantity-specific calls. In ApplyRunnerPreset(), use BaseContracts instead of DefaultQuantity when calculating qty[105]. Ensure that qty = Math.Max(1, BaseContracts) (to guard against 0) and use that for splitting core/runner. Then, call EnterLong(coreQty, "CORE") etc. as we do, which already takes quantities. Likewise, in the else branch, call EnterLong(qty, "Single")[38]. Also update the ForceEntry block in OnBarUpdate: currently it calls ApplyRunnerPreset(isLong) which internally will now use BaseContracts, so that should be fine once ApplyRunnerPreset is updated – but double-check if any direct EnterLong or EnterShort is used elsewhere (for example, if we had a quick entry method for some other case, update it too).
•	Testing Order Sizing: After the code changes, run a simulation where BaseContracts = 3 (for example) and observe Trades.csv. We expect to see CORE and RUNNER entries with qty 2 and 1 (or 1 and 2 depending how split falls) adding up to 3. If BaseContracts = 4, expect 2 and 2. If BaseContracts = 1, expect a Single with 1. This test ensures the splitting logic with integer math (Math.Max(1, qty/2)) works as intended for all edge cases (we should particularly check odd numbers like 3,5, etc.). We’ll adjust the splitting formula if needed (e.g., to favor CORE or RUNNER differently).
•	Update Logging for Size: Currently, Trades.csv has a “Qty” column which we are populating. That should already capture the contract count per entry. We might consider adding a Contracts column to explicitly state the total contracts for the trade if that adds clarity – but since a trade can have two entries, it might be redundant. Instead, what we will do is ensure RunInfo.txt logs the BaseContracts value (replacing the old “DefaultQuantity” line with “BaseContracts: X”). We see in EnsureLogsInitialized it writes DefaultQuantity: {DefaultQuantity}[112]; that line should be changed to log BaseContracts instead. That way, each run’s config clearly shows how many contracts were intended per trade. In Trades.csv, the “Qty” column already shows actual order quantities (so for a split trade you’ll see e.g. one row qty 2, another qty 1, which implicitly tells you BaseContracts was 3). If needed, we could add a column in Trades.csv for total BaseContracts, but it might be overkill. We’ll likely just rely on the RunInfo and the separate log lines for CORE/RUNNER.
•	Runner Logic Verification: Since lastRunnerPct and related calculations currently depend on DefaultQuantity for initialization (e.g., in EnsureSplitSizingReady we do lastRunnerBasePct = (DefaultQuantity < 2 ? 0.0 : 0.5)[99][113]), we must update that to use BaseContracts. After Pass 16.5, EnsureSplitSizingReady should use BaseContracts instead of DefaultQuantity. Similarly, any condition DefaultQuantity >= 2 becomes BaseContracts >= 2. Essentially search-and-replace DefaultQuantity usage in our code with BaseContracts, except the one line in SetDefaults where we set DefaultQuantity = 1 (that remains as is). This ensures all logic (runner allowed, etc.) keys off the intended contract count.
•	Cleanup DefaultQuantityParam references: Although we removed the property, double-check no stray references remain – e.g., in RunInfo logging or elsewhere. We already spotted the RunInfo writing DefaultQuantity; that will be changed. Also ensure the property is fully deleted from the partial class (it should be, but a sanity check is good).
•	Edge Case Testing: Test with BaseContracts = 2 (minimal runner scenario), = 1 (no runner scenario), = 3 (odd split), = 10 (larger number) to ensure no arithmetic or ordering issues (like SetProfitTarget expecting an order name that doesn’t exist – we name both CORE and Single properly so that’s fine). Also test turning ApplyRunnerManagement off – in that case, even if BaseContracts >= 2, it should treat the order as Single (our allowRunner logic already does that by checking the flag first[114]). Verify that when ApplyRunnerManagement = false and BaseContracts = 3, we get one trade of 3 contracts with a single stop and target.
•	Documentation & UI: Update any strategy property descriptions to mention BaseContracts. Also, ensure the UI GroupName “Position Settings” now contains BaseContracts (and DefaultQuantity is out). If needed, adjust the Order so that BaseContracts appears in a logical place (likely where DefaultQuantity was, order 2 in Position Settings group).
After completing Pass 16.5, the MNQRSTest strategy should be fully functional for multi-contract trading, allowing us to truly utilize the runner strategy on micro NASDAQ. All logs and internal logic will align with the intended position sizing. From there, we proceed to Pass 17 (testing) to confirm everything, and then on to the enhancements like full volume profile integration and further optimizations.
This handover context should equip you (or any new developer/agent) with a complete understanding of the MNQRSTest strategy’s current implementation, the rationale behind design decisions, and the next steps to continue development. Good luck with the upcoming passes, and happy coding!
