NinjaTrader Quirks & Discoveries (Updates)
During development and testing, we encountered new insights and challenges specific to NinjaTrader 8. Here are the latest noteworthy quirks and our workarounds, in addition to those already documented:
•	DefaultQuantity vs Strategy Analyzer: We confirmed that DefaultQuantity cannot be reliably changed at runtime or via optimization. Our earlier attempt using a custom parameter DefaultQuantityParam taught us that NT8 only reads DefaultQuantity on startup (State.SetDefaults) and doesn’t expect it to change thereafter. In fact, trying to sync it during optimization caused null reference issues when NT’s internal DefaultQuantity didn’t match our param. Workaround: as described, we abandoned that approach and moved to using our own BaseContracts for all sizing. We keep DefaultQuantity = 1 always[26], and explicitly submit orders with quantities. This eliminates the NinjaTrader limitation by sidestepping it entirely. One must be cautious: any NinjaScript method that doesn’t allow specifying quantity will use DefaultQuantity=1, so we avoided those. All our entries use EnterLong(quantity, "signalName") overloads now.
•	Logging Performance in Optimization: We discovered that writing to log files (CSV) for every trade and setup can dramatically slow down optimization runs. NinjaTrader runs each optimization iteration in sequence (single-threaded for strategy code), so excessive I/O becomes a bottleneck. For example, a single backtest with verbose logging might be fine, but 500 optimization iterations multiply that cost. We’ve mitigated this by introducing flags to reduce logging. Specifically, LogSetupsVerbose when false stops logging of skipped setups; we log only essential events (like final armed/triggered/expired and trade entries/exits). Additionally, we plan to implement an ExportDuringOptimization toggle that, when false, can completely disable file writes during optimization passes – instead collecting summary stats in memory. A quirk here is NT8 doesn’t have a built-in way for the strategy to know it’s in an optimization vs a regular run. Our approach is usually to provide a manual switch (the user can turn off detailed logs when they intend to optimize). In practice, we found this greatly improves optimization speed and prevents gigabytes of log files. The lesson is: design the strategy to be I/O-efficient, using logging strategically, especially if you intend to leverage NT’s optimizer.
•	Partial Fills and Trade Tracking: In multi-contract scenarios, NT8’s OnExecutionUpdate events for exits needed careful handling. We learned that when using split positions (CORE and RUNNER), NinjaTrader will report executions for each, and we must attribute them correctly to avoid confusion in our logs. We wrote logic to match exit prices to expected stop/target levels for Core vs Runner vs Single[23][27]. One quirk is that if an exit happens at exactly the entry price (e.g. runner stopped at breakeven), our code labels it as “Breakeven” by checking price ≈ lastEntryPrice[28]. We had to include a tiny tolerance (0.5 * tick size) because floating-point comparisons can be tricky. This is a minor NT detail (floats vs decimals) but worth noting: always account for a small epsilon when comparing prices, as NinjaTrader’s floating price values can have tiny imprecisions.
•	Order Handling Constraints: As mentioned, NinjaTrader does not allow altering an existing order’s quantity or type once submitted. We confirmed this when attempting dynamic runner scaling – for example, you cannot scale out half of the runner mid-trade without placing a new order. Our strategy’s approach to “runner scaling” is therefore limited: we adjust an internal percentage and use it to influence the next trade’s sizing or just log the theoretical adjustment. If we wanted to truly act on it in real-time, the only way would be to submit an exit order for part of the position (which would complicate tracking, since NT would then consider it a manual partial exit of that strategy position). We decided not to automate partial exits based on the lastRunnerPct adjustments because it could conflict with our planned exit orders. The takeaway is that NT8 strategies are simplest when you determine all entry quantities upfront; any changes mid-trade must be executed as additional orders (which we chose to avoid for clarity). Future developers should be aware that while we compute adaptive values during a trade (like potentially wanting to tighten a stop if momentum fades), implementing that means explicitly coding new orders or stop modifications. NT’s SetStopLoss and SetProfitTarget can be called to change stops/targets on the fly (by calling again with a new price), which we may use for things like volume-profile-based trailing stops in the future. But one must ensure to identify the correct order (by signal name) when modifying, and NT will apply the change to all matching orders for that signal name. We haven’t fully utilized dynamic stop moves yet, but plan to experiment carefully in forward testing.
•	Strategy Analyzer vs Live Differences: We need to highlight any differences observed between backtest behavior and real-time (or Market Replay) behavior. One known NT8 quirk is that the Strategy Analyzer assumes perfect intra-bar fills for certain order types. We use a breakout entry (stop-market order one tick beyond bar high/low). In backtest, NT can fill that within the same bar if price exceeds the trigger, but in real-time it would be a live resting order. We simulated this with high granularity data and it appears consistent, but traders should be cognizant that backtest might slightly overestimate fills if the breakout and reversal happen in the same bar. To mitigate this, we keep our entry logic conservative (we don’t allow an entry beyond the bar that armed it – if it didn’t break out within a couple bars, we label it expired). This reduces the chance of discrepancy. Another subtlety: our use of BarsSinceEntryExecution to calculate hold time in bars assumes one execution per trade signal; with multiple contracts, NT logs separate executions, but our logic picks the first (which is correct for entry time)[29]. We discovered this while verifying hold times – multiple fills could skew BarsSinceEntry if not handled, so we ensure to call it with the signal name (CORE/RUNNER) to get the right index.
•	Memory and Optimization Load: Running “huge sweeps” (as planned) pushed NT8’s limits in terms of RAM and CPU. We learned to be careful with optimization ranges and increments. For example, sweeping a continuous variable like a decay factor α from 0 to 1 with step 0.01 means 101 iterations – feasible. But doing that for multiple parameters multiplies out (a grid search). It’s easy to set up an optimization that tries, say, 1,000,000 combinations which NT8 cannot practically complete. We discovered that using genetic optimization or particle swarm in NT8 can help explore large parameter spaces more efficiently than brute force grid, at the cost of some stochastic results. For our purposes, we will break up the sweeps into logical chunks (focus on a few critical parameters at once) to manage this. Also, NT8 tends to consume a lot of memory when performing many backtests sequentially; we’ll monitor for any memory leaks or performance degradation. In our tests so far, closing and reopening the Strategy Analyzer between very large runs helps clear resources. A cautionary note: always save your work and logs frequently, as NT can crash if it runs out of memory or if an optimization is too large.
In essence, these discoveries have led us to adjust both our code and usage of NinjaTrader. By structuring the strategy to avoid NT limitations (custom sizing param, limiting on-bar adjustments), and by adjusting our testing approach (reducing logging, sane optimization plans), we ensure the development process is smoother and the strategy runs reliably in both backtest and live conditions.
