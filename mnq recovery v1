// MNQRecoverySimple — explicit filter flags, non-fill reasons, risk columns
// Version: 0.9.5
using System;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Globalization;
using System.IO;
using System.Windows;           // for TextAlignment in Draw.Text
using System.Windows.Media;
using NinjaTrader.Cbi;
using NinjaTrader.Data;
using NinjaTrader.Gui.Tools;
using NinjaTrader.NinjaScript;
using NinjaTrader.NinjaScript.DrawingTools;
using NinjaTrader.NinjaScript.Indicators;
using NinjaTrader.NinjaScript.Strategies;

namespace NinjaTrader.NinjaScript.Strategies
{
    public class MNQRecoverySimple : Strategy
    {
        // ===== Indicators / series =====
        private EMA ema;
        private ATR atr14;
        private Series<double> candleRange;

        // ===== Setup tracking =====
        private bool armedLong;
        private bool armedShort;
        private int  setupBarIndex;
        private double crossingCandleHigh;
        private double crossingCandleLow;

        // Planned order details
        private double triggerPrice;
        private double plannedStopPrice;    // structure stop (candle high/low ± StopTicks)
        private double plannedTargetPrice;  // R multiple from entry
        private int    plannedQty;

        // Working order tracking
        private Order workingEntry;
        private int   workingEntryBarIndex;

        // Blink label state
        private bool blinkVisible = true;
        private DateTime lastBlinkTime = DateTime.MinValue;
        private const double BlinkSeconds = 3.0;
        private SimpleFont labelFont;

        // ===== CSV logging =====
        private string logDir;
        private string tradeLogFile;             // trades
        private string setupLogFile;             // setups (skips/blocks/expiries/cancels)
        private bool   csvEnabled;

        // ===== Snapshots at arm time =====
        private double snap_EmaSlope;
        private double snap_Atr14;
        private double snap_CandleRange;
        private int    snap_TimeHHmmss;

        private double snap_DistToEmaTicks;
        private double snap_AtrTicks;
        private double snap_StopSizeTicks;
        private int    snap_Filter_ATR_OK;
        private int    snap_Filter_Trend_OK;
        private int    snap_Filter_Band_OK;
        private int    snap_StopSize_OK;
        private int    snap_BarsSinceSession;
        private double snap_BandHalfWidthTicks;
        private double snap_DistToBandEdgeTicks;
        private int    snap_BeyondBandFlag;

        // QS snapshots
        private double snap_QualityScore;
        private double snap_QS_ATR;
        private double snap_QS_Slope;
        private double snap_QS_Dist;
        private double snap_QS_Stop;

        // ===== Trade lifecycle =====
        private bool           inTrade;
        private MarketPosition tradeSide = MarketPosition.Flat;
        private double         tradeEntryPrice;
        private DateTime       tradeEntryTime;

        // IDs
        private int   tradeIdSeq = 0;
        private int   currentTradeId = 0;

        private int    setupSeq = 0;
        private string currentSetupId = "";

        // Session
        private int barsSinceSessionOpen = 0;

        // ===== Non-fill tracing =====
        private int currTriggered = 0;        // hit trigger?
        private int currOrderPlaced = 0;      // submitted limit?
        private string currNonFillReason = ""; // final reason when no fill

        // ===== Events =====
        private enum SetupEventType
        {
            BlockedByTime,
            SkipFilters,
            SkipQualityScore,
            SetupExpired,
            OrderCancelledAdverse,
            OrderCancelledExpiry,
            OrderRejectedOrCancelled
        }

        // ===== Debug overlay =====
        [NinjaScriptProperty]
        [Display(Name = "Debug Overlay", Order = 1, GroupName = "Debug")]
        public bool DebugOverlay { get; set; } = true;

        [NinjaScriptProperty, Range(0, int.MaxValue)]
        [Display(Name = "Debug Max Marks per Session", Order = 2, GroupName = "Debug")]
        public int DebugMaxMarks { get; set; } = 200;

        private int debugMarksCount = 0;
        private void DebugMark(string kind, string msg, Brush brush)
        {
            if (!DebugOverlay) return;
            if (DebugMaxMarks > 0 && debugMarksCount >= DebugMaxMarks) return;

            string tag = $"DBG_{kind}_{CurrentBar}_{debugMarksCount}";
            double y = (High[0] + Low[0]) * 0.5;

            Draw.Dot(this, tag + "_dot", false, 0, y, brush);
            Draw.Text(this, tag + "_txt", false, msg, 0, High[0], 0, brush, labelFont,
                      TextAlignment.Left, Brushes.Transparent, Brushes.Transparent, 0);
            debugMarksCount++;
        }

        // ===== Parameters =====
        [NinjaScriptProperty, Range(1, int.MaxValue)]
        [Display(Name="EMA Period", Order=1, GroupName="Setup")]
        public int EmaPeriod { get; set; }

        [NinjaScriptProperty, Range(0.1, double.MaxValue)]
        [Display(Name="Small Candle Threshold (× SMA20 of range)", Order=2, GroupName="Setup")]
        public double SmallCandleThreshold { get; set; }

        [NinjaScriptProperty, Range(0, int.MaxValue)]
        [Display(Name="Entry Ticks (offset from trigger)", Order=3, GroupName="Orders")]
        public int EntryTicks { get; set; }

        [NinjaScriptProperty, Range(1, int.MaxValue)]
        [Display(Name="Stop Ticks (buffer beyond candle)", Order=4, GroupName="Orders")]
        public int StopTicks { get; set; }

        [NinjaScriptProperty, Range(0.1, double.MaxValue)]
        [Display(Name="Reward Multiple (R)", Order=5, GroupName="Orders")]
        public double RewardMultiple { get; set; }

        [NinjaScriptProperty, Range(1, int.MaxValue)]
        [Display(Name="Setup Expiry Bars", Order=6, GroupName="Setup")]
        public int SetupExpiryBars { get; set; }

        // Risk guards
        [NinjaScriptProperty, Range(0, int.MaxValue)]
        [Display(Name="Min Stop Ticks", Order=9, GroupName="Orders")]
        public int MinStopTicks { get; set; } = 8;

        [NinjaScriptProperty, Range(0, int.MaxValue)]
        [Display(Name="Max Stop Ticks (0 = no cap)", Order=10, GroupName="Orders")]
        public int MaxStopTicks { get; set; } = 100;  // default bumped to 100

        [NinjaScriptProperty, Range(0, int.MaxValue)]
        [Display(Name="Max Adverse Ticks Before Cancel", Order=11, GroupName="Orders")]
        public int MaxAdverseTicksBeforeCancel { get; set; } = 24;

        [NinjaScriptProperty, Range(0, int.MaxValue)]
        [Display(Name="Working Order Expiry Bars (0=off)", Order=12, GroupName="Orders")]
        public int WorkingOrderExpiryBars { get; set; } = 12;

        // Position sizing
        [NinjaScriptProperty, Range(0, double.MaxValue)]
        [Display(Name="Dollars Risk Per Trade (0 = fixed Contracts)", Order=7, GroupName="Sizing")]
        public double DollarsRiskPerTrade { get; set; }

        [NinjaScriptProperty, Range(1, int.MaxValue)]
        [Display(Name="Contracts (used if DollarsRiskPerTrade = 0)", Order=8, GroupName="Sizing")]
        public int Contracts { get; set; }

        [NinjaScriptProperty, Range(1, int.MaxValue)]
        [Display(Name="Max Contracts", Order=9, GroupName="Sizing")]
        public int MaxContracts { get; set; } = 5;

        // QS-based sizing
        [NinjaScriptProperty]
        [Display(Name="Use QS Size Modulation", Order=12, GroupName="Sizing")]
        public bool UseQSSizeModulation { get; set; } = true;

        [NinjaScriptProperty, Range(0.1, 10.0)]
        [Display(Name="QS Size Min Scale", Order=13, GroupName="Sizing")]
        public double QS_MinScale { get; set; } = 0.75;

        [NinjaScriptProperty, Range(0.1, 10.0)]
        [Display(Name="QS Size Max Scale", Order=14, GroupName="Sizing")]
        public double QS_MaxScale { get; set; } = 1.50;

        [NinjaScriptProperty, Range(0.0, 100.0)]
        [Display(Name="QS Midpoint (score)", Order=15, GroupName="Sizing")]
        public double QS_Midpoint { get; set; } = 50.0;

        [NinjaScriptProperty, Range(0.0, 10.0)]
        [Display(Name="QS Size Curve (steepness)", Order=16, GroupName="Sizing")]
        public double QS_Curve { get; set; } = 1.0;

        [NinjaScriptProperty]
        [Display(Name="QS Modulates Risk Budget (if $ risk mode)", Order=17, GroupName="Sizing")]
        public bool QS_ModulatesRiskBudget { get; set; } = false;

        // Session filter
        [NinjaScriptProperty]
        [Display(Name="Use Time Filter", Order=1, GroupName="Session")]
        public bool UseTimeFilter { get; set; }

        [NinjaScriptProperty]
        [Display(Name="Start Time (HHmmss)", Order=2, GroupName="Session")]
        public int StartTime { get; set; }

        [NinjaScriptProperty]
        [Display(Name="End Time (HHmmss)", Order=3, GroupName="Session")]
        public int EndTime { get; set; }

        [NinjaScriptProperty]
        [Display(Name="Exclude Lunch Start (HHmmss, 0=off)", Order=4, GroupName="Session")]
        public int ExcludeStart { get; set; }

        [NinjaScriptProperty]
        [Display(Name="Exclude Lunch End (HHmmss, 0=off)", Order=5, GroupName="Session")]
        public int ExcludeEnd { get; set; }

        // Filters
        [NinjaScriptProperty]
        [Display(Name="Use ATR Filter", Order=1, GroupName="Filters")]
        public bool UseAtrFilter { get; set; } = true;

        [NinjaScriptProperty, Range(0.0, double.MaxValue)]
        [Display(Name="ATR Min (ticks)", Order=2, GroupName="Filters")]
        public double AtrMinTicks { get; set; } = 20;

        [NinjaScriptProperty, Range(0.0, double.MaxValue)]
        [Display(Name="ATR Max (ticks)", Order=3, GroupName="Filters")]
        public double AtrMaxTicks { get; set; } = 75;

        [NinjaScriptProperty]
        [Display(Name="Use Trend Filter", Order=4, GroupName="Filters")]
        public bool UseTrendFilter { get; set; } = true;

        [NinjaScriptProperty, Range(0.0, double.MaxValue)]
        [Display(Name="EMA Slope Min (ticks)", Order=5, GroupName="Filters")]
        public double EmaSlopeMinTicks { get; set; } = 0.25;

        [NinjaScriptProperty, Range(0.0, double.MaxValue)]
        [Display(Name="Dist to EMA Min (ticks)", Order=6, GroupName="Filters")]
        public double DistToEmaMinTicks { get; set; } = 2.0;

        [NinjaScriptProperty]
        [Display(Name="Use EMA Band Filter", Order=7, GroupName="Filters")]
        public bool UseEmaBandFilter { get; set; } = true;

        [NinjaScriptProperty, Range(0.0, 10.0)]
        [Display(Name="EMA Band ATR Mult", Order=8, GroupName="Filters")]
        public double EmaBandAtrMult { get; set; } = 0.50;

        // Quality Score
        [NinjaScriptProperty]
        [Display(Name="Use Quality Score", Order=1, GroupName="Quality")]
        public bool UseQualityScore { get; set; } = true;

        [NinjaScriptProperty, Range(0.0, 100.0)]
        [Display(Name="Quality Min Threshold (0-100)", Order=2, GroupName="Quality")]
        public double QualityMinThreshold { get; set; } = 62.0;

        [NinjaScriptProperty, Range(0.0, 1.0)]
        [Display(Name="QS Weight: ATR", Order=3, GroupName="Quality")]
        public double QS_Weight_ATR { get; set; } = 0.20;

        [NinjaScriptProperty, Range(0.0, 1.0)]
        [Display(Name="QS Weight: EMA Slope", Order=4, GroupName="Quality")]
        public double QS_Weight_Slope { get; set; } = 0.35;

        [NinjaScriptProperty, Range(0.0, 1.0)]
        [Display(Name="QS Weight: Dist to EMA", Order=5, GroupName="Quality")]
        public double QS_Weight_Dist { get; set; } = 0.10;

        [NinjaScriptProperty, Range(0.0, 1.0)]
        [Display(Name="QS Weight: Stop Size", Order=6, GroupName="Quality")]
        public double QS_Weight_Stop { get; set; } = 0.35;

        [NinjaScriptProperty, Range(1, int.MaxValue)]
        [Display(Name="Stop Size Ideal (ticks)", Order=7, GroupName="Quality")]
        public int StopSizeIdealTicks { get; set; } = 12;

        [NinjaScriptProperty, Range(1, int.MaxValue)]
        [Display(Name="Stop Size Max (ticks)", Order=8, GroupName="Quality")]
        public int StopSizeMaxTicks { get; set; } = 40;

        // Diagnostics
        [NinjaScriptProperty]
        [Display(Name="Enable CSV Logging", Order=10, GroupName="Diagnostics")]
        public bool EnableCsvLogging { get; set; } = true;

        protected override void OnStateChange()
        {
            if (State == State.SetDefaults)
            {
                Name = "MNQRecoverySimple";
                Calculate = Calculate.OnBarClose;
                EntriesPerDirection = 1;
                EntryHandling = EntryHandling.AllEntries;
                IsExitOnSessionCloseStrategy = true;
                ExitOnSessionCloseSeconds = 30;

                // Setup defaults
                EmaPeriod = 62;
                SmallCandleThreshold = 0.5;
                EntryTicks = 1;
                StopTicks = 8;
                RewardMultiple = 1.0;
                SetupExpiryBars = 20;

                DollarsRiskPerTrade = 0;
                Contracts = 2;
                MaxContracts = 5;

                UseTimeFilter = false;
                StartTime = 100000;
                EndTime   = 150000;
                ExcludeStart = 0;
                ExcludeEnd   = 0;
            }
            else if (State == State.DataLoaded)
            {
                ema = EMA(Close, EmaPeriod);
                atr14 = ATR(14);
                candleRange = new Series<double>(this);

                armedLong = armedShort = false;
                crossingCandleHigh = crossingCandleLow = 0;
                setupBarIndex = 0;

                labelFont = new SimpleFont("Segoe UI", 14) { Bold = true };

                // CSV init
                csvEnabled = EnableCsvLogging;
                logDir  = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments),
                                       "NinjaTrader 8", "strategies", "MNQRecoverySimple");
                tradeLogFile = Path.Combine(logDir, "MNQRecoverySimple_Trades.csv");
                setupLogFile = Path.Combine(logDir, "MNQRecoverySimple_Setups.csv");

                try
                {
                    if (csvEnabled)
                    {
                        if (!Directory.Exists(logDir))
                            Directory.CreateDirectory(logDir);

                        File.WriteAllText(tradeLogFile,
                            "Date,Time,SetupId,TradeId,Direction,EntryPrice,StopPrice,TargetPrice,R,Qty," +
                            "EMA_Slope,ATR14,CandleRange,TimeHHmmss,ExitPrice,ResultTicks,ResultUSD," +
                            "EmaSlopeTicks,ATRTicks,DistToEMATicks,ATR_FilterOK,Trend_FilterOK,InitRiskTicks," +
                            "QualityScore,Q_ATR,Q_Slope,Q_DistEMA,Q_Stop,QS_SizeScale,BarsSinceSession,BandHalfWidthTicks,DistToBandEdgeTicks,BeyondBandFlag\n");

                        // NOTE: new columns PerContractRiskUSD, PlannedRiskUSD added after StopSizeTicks
                        File.WriteAllText(setupLogFile,
                            "Date,Time,Bar,SetupId,Event,Direction,QS,QAtr,QSlope,QDist,QStop," +
                            "ATRTicks,EmaSlopeTicks,DistToEMATicks,StopSizeTicks,PerContractRiskUSD,PlannedRiskUSD,TrigPrice,StopPrice,TargetPrice,R,Qty," +
                            "StartTime,EndTime,ExcludeStart,ExcludeEnd,BarsSinceSession,BandHalfWidthTicks,DistToBandEdgeTicks,BeyondBandFlag," +
                            "AtrOk,TrendOk,BandOk,StopOk,Triggered,OrderPlaced,NonFillReason,Notes\n");
                    }
                }
                catch (Exception ex)
                {
                    Print($"[CSV INIT ERROR] {ex.Message}");
                    csvEnabled = false;
                }
            }
        }
        protected override void OnBarUpdate()
        {
            if (CurrentBar < Math.Max(EmaPeriod + 20, 50))
                return;

            // Track session
            if (Bars.IsFirstBarOfSession) { barsSinceSessionOpen = 0; debugMarksCount = 0; }
            else barsSinceSessionOpen++;

            // Time filter (log only if candidate exists)
            if (UseTimeFilter)
            {
                int t = ToTime(Time[0]);
                bool blocked = (t < StartTime || t > EndTime) ||
                               (ExcludeStart > 0 && ExcludeEnd > 0 && t >= ExcludeStart && t <= ExcludeEnd);
                if (blocked)
                {
                    // Only log if this bar could have armed
                    candleRange[0] = High[0] - Low[0];
                    bool smallNow = candleRange[0] < SmallCandleThreshold * SMA(candleRange, 20)[0];
                    bool crossCandidate = (Close[1] > ema[1] && Close[0] < ema[0]) || (Close[1] < ema[1] && Close[0] > ema[0]);
                    if (smallNow && crossCandidate)
                    {
                        LogSetupEvent(SetupEventType.BlockedByTime, "", "", 0,0,0,0,0,
                                      0,0,0,0,
                                      0.0,0.0,
                                      0,0,0, RewardMultiple, 0,
                                      barsSinceSessionOpen, 0,0,0,
                                      0,0,0,0, 0,0, $"t={t} blocked by session window", $"t={t} blocked by session window");
                        DebugMark("TIME", "TIME BLOCK", Brushes.Goldenrod);
                    }
                    armedLong = armedShort = false;
                    DrawStatusLabel();
                    return;
                }
            }

            // Range context
            candleRange[0] = High[0] - Low[0];
            double avgRange = SMA(candleRange, 20)[0];
            bool smallCandle = candleRange[0] < SmallCandleThreshold * avgRange;

            if (!armedLong && !armedShort && smallCandle)
            {
                // ===== SHORT (bearish cross) =====
                if (Close[1] > ema[1] && Close[0] < ema[0])
                {
                    crossingCandleHigh = High[0];
                    crossingCandleLow  = Low[0];
                    setupBarIndex = CurrentBar;

                    int bufferTicks = Math.Max(StopTicks, MinStopTicks);
                    triggerPrice = crossingCandleLow - EntryTicks * TickSize; // short trigger below low
                    plannedStopPrice   = crossingCandleHigh + bufferTicks * TickSize;
                    plannedTargetPrice = triggerPrice - (plannedStopPrice - triggerPrice) * RewardMultiple;

                    double stopSizeTicks = (plannedStopPrice - triggerPrice) / TickSize;
                    double emaSlopeTicks = (ema[0] - ema[1]) / TickSize;
                    double distToEmaTicks = Math.Abs(triggerPrice - ema[0]) / TickSize;
                    double atrTicks = atr14[0] / TickSize;

                    // NEW: per-contract $ risk for this setup
                    double perRiskUSD = stopSizeTicks * TickSize * Instrument.MasterInstrument.PointValue;

                    double bandHalfWidthTicks = (atr14[0] / TickSize) * Math.Max(0.0, EmaBandAtrMult);
                    double distToBandEdgeTicks = Math.Max(0.0, bandHalfWidthTicks - distToEmaTicks);
                    bool beyondBand = distToBandEdgeTicks <= 0.0;

                    bool atrOk   = !UseAtrFilter   || (atrTicks >= AtrMinTicks && atrTicks <= AtrMaxTicks);
                    bool trendOk = !UseTrendFilter || (Math.Abs(emaSlopeTicks) >= EmaSlopeMinTicks && distToEmaTicks >= DistToEmaMinTicks);
                    bool bandOk  = !UseEmaBandFilter || beyondBand;
                    bool stopOk  = (stopSizeTicks >= MinStopTicks) && (MaxStopTicks <= 0 || stopSizeTicks <= MaxStopTicks);
                    bool allOk   = atrOk && trendOk && bandOk && stopOk;

                    double qAtr, qSlope, qDist, qStop;
                    double qScore = ComputeQualityScore(atrTicks, Math.Abs(emaSlopeTicks), distToEmaTicks, stopSizeTicks,
                                                        out qAtr, out qSlope, out qDist, out qStop);

                    if (!allOk)
                    {
                        string why = $"FiltersFailed: atrOk={atrOk} trendOk={trendOk} bandOk={bandOk} stopOk={stopOk} " +
                                     $"stopSizeTicks={stopSizeTicks:F1} minStopTicks={MinStopTicks} maxStopTicks={MaxStopTicks} " +
                                     $"atrTicks={atrTicks:F1} emaSlopeTicks={emaSlopeTicks:F2} distToEmaTicks={distToEmaTicks:F1}";
                        string tmpId = NewSetupId("Short");
                        LogSetupEvent(SetupEventType.SkipFilters, tmpId, "Short", qScore, qAtr, qSlope, qDist, qStop,
                                      atrTicks, emaSlopeTicks, distToEmaTicks, stopSizeTicks,
                                      perRiskUSD, 0.0,
                                      triggerPrice, plannedStopPrice, plannedTargetPrice, RewardMultiple, 0,
                                      barsSinceSessionOpen, bandHalfWidthTicks, distToBandEdgeTicks, beyondBand ? 1 : 0,
                                      atrOk ? 1 : 0, trendOk ? 1 : 0, bandOk ? 1 : 0, stopOk ? 1 : 0,
                                      0, 0, "", why);
                        DebugMark("SKIP", "SKIP SHORT\n" + why, Brushes.OrangeRed);
                    }
                    else if (UseQualityScore && qScore < QualityMinThreshold)
                    {
                        string why = $"QS {qScore:F1} < {QualityMinThreshold:F1}";
                        string tmpId = NewSetupId("Short");
                        LogSetupEvent(SetupEventType.SkipQualityScore, tmpId, "Short", qScore, qAtr, qSlope, qDist, qStop,
                                      atrTicks, emaSlopeTicks, distToEmaTicks, stopSizeTicks,
                                      perRiskUSD, 0.0,
                                      triggerPrice, plannedStopPrice, plannedTargetPrice, RewardMultiple, 0,
                                      barsSinceSessionOpen, bandHalfWidthTicks, distToBandEdgeTicks, beyondBand ? 1 : 0,
                                      atrOk ? 1 : 0, trendOk ? 1 : 0, bandOk ? 1 : 0, stopOk ? 1 : 0,
                                      0, 0, "", why);
                        DebugMark("QS", "QS SKIP SHORT\n" + why, Brushes.SlateBlue);
                    }
                    else
                    {
                        // Arm SHORT
                        armedShort = true; armedLong = false;
                        currentSetupId = NewSetupId("Short");

                        // qty with QS scaling
                        double perContractDollarRisk = Math.Abs(plannedStopPrice - triggerPrice) * Instrument.MasterInstrument.PointValue;
                        snap_QualityScore = qScore; snap_QS_ATR = qAtr; snap_QS_Slope = qSlope; snap_QS_Dist = qDist; snap_QS_Stop = qStop;
                        int qty = ComputePlannedQtyWithQS(perContractDollarRisk, snap_QualityScore);
                        plannedQty = qty;

                        // snapshots
                        snap_EmaSlope    = ema[0] - ema[1];
                        snap_Atr14       = atr14[0];
                        snap_CandleRange = candleRange[0];
                        snap_TimeHHmmss  = ToTime(Time[0]);
                        snap_DistToEmaTicks = distToEmaTicks;
                        snap_AtrTicks = atrTicks;
                        snap_StopSizeTicks = stopSizeTicks;
                        snap_Filter_ATR_OK = atrOk ? 1 : 0;
                        snap_Filter_Trend_OK = trendOk ? 1 : 0;
                        snap_Filter_Band_OK = bandOk ? 1 : 0;
                        snap_StopSize_OK = stopOk ? 1 : 0;
                        snap_BarsSinceSession = barsSinceSessionOpen;
                        snap_BandHalfWidthTicks = bandHalfWidthTicks;
                        snap_DistToBandEdgeTicks = distToBandEdgeTicks;
                        snap_BeyondBandFlag = beyondBand ? 1 : 0;

                        // reset non-fill trackers
                        currTriggered = 0;
                        currOrderPlaced = 0;
                        currNonFillReason = "";

                        DebugMark("ARM", $"ARM SHORT\nQS={qScore:F1}", Brushes.MediumSeaGreen);
                    }
                }
                // ===== LONG (bullish cross) =====
                else if (Close[1] < ema[1] && Close[0] > ema[0])
                {
                    crossingCandleHigh = High[0];
                    crossingCandleLow  = Low[0];
                    setupBarIndex = CurrentBar;

                    int bufferTicks = Math.Max(StopTicks, MinStopTicks);
                    triggerPrice = crossingCandleHigh + EntryTicks * TickSize;  // long trigger above high
                    plannedStopPrice   = crossingCandleLow - bufferTicks * TickSize;
                    plannedTargetPrice = triggerPrice + (triggerPrice - plannedStopPrice) * RewardMultiple;

                    double stopSizeTicks = (triggerPrice - plannedStopPrice) / TickSize;
                    double emaSlopeTicks = (ema[0] - ema[1]) / TickSize;
                    double distToEmaTicks = Math.Abs(triggerPrice - ema[0]) / TickSize;
                    double atrTicks = atr14[0] / TickSize;

                    // NEW: per-contract $ risk for this setup
                    double perRiskUSD = stopSizeTicks * TickSize * Instrument.MasterInstrument.PointValue;

                    double bandHalfWidthTicks = (atr14[0] / TickSize) * Math.Max(0.0, EmaBandAtrMult);
                    double distToBandEdgeTicks = Math.Max(0.0, bandHalfWidthTicks - distToEmaTicks);
                    bool beyondBand = distToBandEdgeTicks <= 0.0;

                    bool atrOk   = !UseAtrFilter   || (atrTicks >= AtrMinTicks && atrTicks <= AtrMaxTicks);
                    bool trendOk = !UseTrendFilter || (Math.Abs(emaSlopeTicks) >= EmaSlopeMinTicks && distToEmaTicks >= DistToEmaMinTicks);
                    bool bandOk  = !UseEmaBandFilter || beyondBand;
                    bool stopOk  = (stopSizeTicks >= MinStopTicks) && (MaxStopTicks <= 0 || stopSizeTicks <= MaxStopTicks);
                    bool allOk   = atrOk && trendOk && bandOk && stopOk;

                    double qAtr, qSlope, qDist, qStop;
                    double qScore = ComputeQualityScore(atrTicks, Math.Abs(emaSlopeTicks), distToEmaTicks, stopSizeTicks,
                                                        out qAtr, out qSlope, out qDist, out qStop);

                    if (!allOk)
                    {
                        string why = $"FiltersFailed: atrOk={atrOk} trendOk={trendOk} bandOk={bandOk} stopOk={stopOk} " +
                                     $"stopSizeTicks={stopSizeTicks:F1} minStopTicks={MinStopTicks} maxStopTicks={MaxStopTicks} " +
                                     $"atrTicks={atrTicks:F1} emaSlopeTicks={emaSlopeTicks:F2} distToEmaTicks={distToEmaTicks:F1}";
                        string tmpId = NewSetupId("Long");
                        LogSetupEvent(SetupEventType.SkipFilters, tmpId, "Long", qScore, qAtr, qSlope, qDist, qStop,
                                      atrTicks, emaSlopeTicks, distToEmaTicks, stopSizeTicks,
                                      perRiskUSD, 0.0,
                                      triggerPrice, plannedStopPrice, plannedTargetPrice, RewardMultiple, 0,
                                      barsSinceSessionOpen, bandHalfWidthTicks, distToBandEdgeTicks, beyondBand ? 1 : 0,
                                      atrOk ? 1 : 0, trendOk ? 1 : 0, bandOk ? 1 : 0, stopOk ? 1 : 0,
                                      0, 0, "", why);
                        DebugMark("SKIP", "SKIP LONG\n" + why, Brushes.OrangeRed);
                    }
                    else if (UseQualityScore && qScore < QualityMinThreshold)
                    {
                        string why = $"QS {qScore:F1} < {QualityMinThreshold:F1}";
                        string tmpId = NewSetupId("Long");
                        LogSetupEvent(SetupEventType.SkipQualityScore, tmpId, "Long", qScore, qAtr, qSlope, qDist, qStop,
                                      atrTicks, emaSlopeTicks, distToEmaTicks, stopSizeTicks,
                                      perRiskUSD, 0.0,
                                      triggerPrice, plannedStopPrice, plannedTargetPrice, RewardMultiple, 0,
                                      barsSinceSessionOpen, bandHalfWidthTicks, distToBandEdgeTicks, beyondBand ? 1 : 0,
                                      atrOk ? 1 : 0, trendOk ? 1 : 0, bandOk ? 1 : 0, stopOk ? 1 : 0,
                                      0, 0, "", why);
                        DebugMark("QS", "QS SKIP LONG\n" + why, Brushes.SlateBlue);
                    }
                    else
                    {
                        // Arm LONG
                        armedLong = true; armedShort = false;
                        currentSetupId = NewSetupId("Long");

                        double perContractDollarRisk = Math.Abs(triggerPrice - plannedStopPrice) * Instrument.MasterInstrument.PointValue;
                        snap_QualityScore = qScore; snap_QS_ATR = qAtr; snap_QS_Slope = qSlope; snap_QS_Dist = qDist; snap_QS_Stop = qStop;
                        int qty = ComputePlannedQtyWithQS(perContractDollarRisk, snap_QualityScore);
                        plannedQty = qty;

                        snap_EmaSlope    = ema[0] - ema[1];
                        snap_Atr14       = atr14[0];
                        snap_CandleRange = candleRange[0];
                        snap_TimeHHmmss  = ToTime(Time[0]);
                        snap_DistToEmaTicks = distToEmaTicks;
                        snap_AtrTicks = atrTicks;
                        snap_StopSizeTicks = stopSizeTicks;
                        snap_Filter_ATR_OK = atrOk ? 1 : 0;
                        snap_Filter_Trend_OK = trendOk ? 1 : 0;
                        snap_Filter_Band_OK = bandOk ? 1 : 0;
                        snap_StopSize_OK = stopOk ? 1 : 0;
                        snap_BarsSinceSession = barsSinceSessionOpen;
                        snap_BandHalfWidthTicks = bandHalfWidthTicks;
                        snap_DistToBandEdgeTicks = distToEmaTicks; // (long side)
                        snap_BeyondBandFlag = beyondBand ? 1 : 0;

                        // reset non-fill trackers
                        currTriggered = 0;
                        currOrderPlaced = 0;
                        currNonFillReason = "";

                        DebugMark("ARM", $"ARM LONG\nQS={qScore:F1}", Brushes.MediumSeaGreen);
                    }
                }
            }

            // Auto-expire armed state
            if ((armedLong || armedShort) && CurrentBar - setupBarIndex > SetupExpiryBars)
            {
                string dir = armedLong ? "Long" : "Short";
                string expiredWhy = (currTriggered == 0)
                    ? $"Never hit trigger within {SetupExpiryBars} bars"
                    : (currOrderPlaced == 0 ? "Triggered but limit not placed" : "Triggered but no fill before expiry");

                // compute $ risk at log time from snap_StopSizeTicks
                double perRiskUSD = snap_StopSizeTicks * TickSize * Instrument.MasterInstrument.PointValue;
                double plannedRiskUSD = perRiskUSD * plannedQty;

                LogSetupEvent(SetupEventType.SetupExpired, currentSetupId, dir, snap_QualityScore,
                    snap_QS_ATR, snap_QS_Slope, snap_QS_Dist, snap_QS_Stop,
                    snap_AtrTicks, (snap_EmaSlope / TickSize), snap_DistToEmaTicks, snap_StopSizeTicks,
                    perRiskUSD, plannedRiskUSD,
                    triggerPrice, plannedStopPrice, plannedTargetPrice, RewardMultiple, plannedQty,
                    snap_BarsSinceSession, snap_BandHalfWidthTicks, snap_DistToBandEdgeTicks, snap_BeyondBandFlag,
                    snap_Filter_ATR_OK, snap_Filter_Trend_OK, snap_Filter_Band_OK, snap_StopSize_OK,
                    currTriggered, currOrderPlaced, expiredWhy,
                    $"Expired after {SetupExpiryBars} bars");

                DebugMark("EXP", $"EXPIRED {dir}", Brushes.Orange);

                armedLong = armedShort = false;
                currentSetupId = "";
            }

            // Place limit orders (OCO first)
            if (Position.MarketPosition == MarketPosition.Flat && workingEntry == null)
            {
                if (armedLong && High[0] >= crossingCandleHigh + EntryTicks * TickSize)
                {
                    currTriggered = 1;
                    SetStopLoss   ("LongEntry",  CalculationMode.Price, plannedStopPrice,   false);
                    SetProfitTarget("LongEntry", CalculationMode.Price, plannedTargetPrice, false);
                    workingEntry = EnterLongLimit(plannedQty, triggerPrice, "LongEntry");
                    currOrderPlaced = 1;
                    workingEntryBarIndex = CurrentBar;
                    armedLong = false;
                    DebugMark("LMT", "LONG LIMIT", Brushes.DodgerBlue);
                }
                else if (armedShort && Low[0] <= crossingCandleLow - EntryTicks * TickSize)
                {
                    currTriggered = 1;
                    SetStopLoss   ("ShortEntry",  CalculationMode.Price, plannedStopPrice,   false);
                    SetProfitTarget("ShortEntry", CalculationMode.Price, plannedTargetPrice, false);
                    workingEntry = EnterShortLimit(plannedQty, triggerPrice, "ShortEntry");
                    currOrderPlaced = 1;
                    workingEntryBarIndex = CurrentBar;
                    armedShort = false;
                    DebugMark("LMT", "SHORT LIMIT", Brushes.DodgerBlue);
                }
            }

            // Cancel working entry if adverse move or timeout
            if (workingEntry != null && workingEntry.OrderState == OrderState.Working)
            {
                double adverseTicks = 0;
                if (workingEntry.Name == "LongEntry")
                    adverseTicks = (triggerPrice - Low[0]) / TickSize;  // away from long
                else
                    adverseTicks = (High[0] - triggerPrice) / TickSize; // away from short

                bool adverse = MaxAdverseTicksBeforeCancel > 0 && adverseTicks > MaxAdverseTicksBeforeCancel;
                bool expired = WorkingOrderExpiryBars > 0 && CurrentBar - workingEntryBarIndex >= WorkingOrderExpiryBars;

                if (adverse || expired)
                {
                    var evtType = expired ? SetupEventType.OrderCancelledExpiry : SetupEventType.OrderCancelledAdverse;
                    string why = expired ? $"Working expiry {WorkingOrderExpiryBars} bars" : $"Adverse move {adverseTicks:F0} > {MaxAdverseTicksBeforeCancel} ticks";
                    string dir = workingEntry?.Name == "LongEntry" ? "Long" : "Short";
                    currNonFillReason = why;

                    // compute from snapshots
                    double perRiskUSD = snap_StopSizeTicks * TickSize * Instrument.MasterInstrument.PointValue;
                    double plannedRiskUSD = perRiskUSD * plannedQty;

                    LogSetupEvent(evtType, currentSetupId, dir, snap_QualityScore,
                        snap_QS_ATR, snap_QS_Slope, snap_QS_Dist, snap_QS_Stop,
                        snap_AtrTicks, (snap_EmaSlope / TickSize), snap_DistToEmaTicks, snap_StopSizeTicks,
                        perRiskUSD, plannedRiskUSD,
                        triggerPrice, plannedStopPrice, plannedTargetPrice, RewardMultiple, plannedQty,
                        snap_BarsSinceSession, snap_BandHalfWidthTicks, snap_DistToBandEdgeTicks, snap_BeyondBandFlag,
                        snap_Filter_ATR_OK, snap_Filter_Trend_OK, snap_Filter_Band_OK, snap_StopSize_OK,
                        currTriggered, currOrderPlaced, why, why);

                    DebugMark("CXL", evtType==SetupEventType.OrderCancelledExpiry ? "CANCEL EXPIRY" : "CANCEL ADVERSE", Brushes.Purple);
                    CancelOrder(workingEntry);
                }
            }

            // Update status label
            DrawStatusLabel();
        }
        // ===== Execution logging =====
        protected override void OnExecutionUpdate(Execution execution, string executionId, double price, int quantity,
                                                  MarketPosition marketPosition, string orderId, DateTime time)
        {
            if (execution?.Order == null || execution.Order.OrderState != OrderState.Filled)
                return;

            // Clear working handle once entry fills
            if (execution.Order.Name == "LongEntry" || execution.Order.Name == "ShortEntry")
                workingEntry = null;

            // ENTRY fills
            if (execution.Order.Name == "LongEntry" || execution.Order.Name == "ShortEntry")
            {
                if (execution.Order.Name == "LongEntry")
                {
                    double structStop = crossingCandleLow - Math.Max(StopTicks, MinStopTicks) * TickSize;
                    double tgt = price + (price - structStop) * RewardMultiple;
                    SetStopLoss   ("LongEntry",  CalculationMode.Price, structStop, false);
                    SetProfitTarget("LongEntry", CalculationMode.Price, tgt,       false);
                    tradeSide = MarketPosition.Long;
                }
                else
                {
                    double structStop = crossingCandleHigh + Math.Max(StopTicks, MinStopTicks) * TickSize;
                    double tgt = price - (structStop - price) * RewardMultiple;
                    SetStopLoss   ("ShortEntry",  CalculationMode.Price, structStop, false);
                    SetProfitTarget("ShortEntry", CalculationMode.Price, tgt,       false);
                    tradeSide = MarketPosition.Short;
                }

                string suffix = CurrentBar + "_" + execution.Order.Name + "_" + time.ToString("HHmmssfff");
                Draw.HorizontalLine(this, "EntryLine_"  + suffix, price,   Brushes.DodgerBlue);
                Draw.HorizontalLine(this, "StopLine_"   + suffix, (execution.Order.Name=="LongEntry" ? crossingCandleLow - Math.Max(StopTicks, MinStopTicks) * TickSize : crossingCandleHigh + Math.Max(StopTicks, MinStopTicks) * TickSize), Brushes.OrangeRed);
                Draw.HorizontalLine(this, "TargetLine_" + suffix, (execution.Order.Name=="LongEntry" ? price + (price - (crossingCandleLow - Math.Max(StopTicks, MinStopTicks) * TickSize)) * RewardMultiple : price - ((crossingCandleHigh + Math.Max(StopTicks, MinStopTicks) * TickSize) - price) * RewardMultiple), Brushes.MediumSeaGreen);

                inTrade = true;
                tradeEntryPrice = price;
                tradeEntryTime  = time;
                currentTradeId = ++tradeIdSeq;
                DebugMark("FILL", tradeSide == MarketPosition.Long ? "LONG FILL" : "SHORT FILL", Brushes.LimeGreen);
                return;
            }

            // EXIT fills (flattened)
            if (inTrade && Position.MarketPosition == MarketPosition.Flat)
            {
                double exitPrice = execution.Price;
                double resultTicks = 0;

                if (tradeSide == MarketPosition.Long)
                    resultTicks = (exitPrice - tradeEntryPrice) / TickSize;
                else if (tradeSide == MarketPosition.Short)
                    resultTicks = (tradeEntryPrice - exitPrice) / TickSize;

                double resultUsd = resultTicks * Instrument.MasterInstrument.PointValue;

                if (csvEnabled)
                {
                    try
                    {
                        string dir = tradeSide == MarketPosition.Long ? "Long" : "Short";

                        double stopP = (tradeSide == MarketPosition.Long)
                            ? crossingCandleLow - Math.Max(StopTicks, MinStopTicks) * TickSize
                            : crossingCandleHigh + Math.Max(StopTicks, MinStopTicks) * TickSize;

                        double targetP = (tradeSide == MarketPosition.Long)
                            ? tradeEntryPrice + (tradeEntryPrice - stopP) * RewardMultiple
                            : tradeEntryPrice - (stopP - tradeEntryPrice) * RewardMultiple;

                        double initRiskTicks = Math.Abs(tradeEntryPrice - stopP) / TickSize;
                        double sizeScaleLogged = UseQSSizeModulation ? QualityScale(snap_QualityScore) : 1.0;

                        string row = string.Format(CultureInfo.InvariantCulture,
                            "{0},{1},{2},{3},{4},{5},{6:F2},{7:F2},{8:F2},{9:F1},{10}," +
                            "{11:F4},{12:F2},{13:F2},{14},{15:F2},{16:F0},{17:F2}," +
                            "{18:F1},{19:F1},{20:F1},{21},{22},{23:F1},{24:F1},{25:F2},{26:F2},{27:F2},{28:F2},{29},{30:F1},{31:F1},{32}\n",
                            tradeEntryTime.ToString("yyyy-MM-dd"),
                            tradeEntryTime.ToString("HH:mm:ss"),
                            currentSetupId,
                            currentTradeId,
                            dir,
                            tradeEntryPrice,
                            stopP,
                            targetP,
                            RewardMultiple,
                            plannedQty,
                            snap_EmaSlope,
                            snap_Atr14,
                            snap_CandleRange,
                            snap_TimeHHmmss,
                            exitPrice,
                            resultTicks,
                            resultUsd,
                            (ema[0] - ema[1]) / TickSize,
                            snap_AtrTicks,
                            snap_DistToEmaTicks,
                            snap_Filter_ATR_OK,
                            snap_Filter_Trend_OK,
                            initRiskTicks,
                            snap_QualityScore,
                            snap_QS_ATR,
                            snap_QS_Slope,
                            snap_QS_Dist,
                            snap_QS_Stop,
                            sizeScaleLogged,
                            snap_BarsSinceSession,
                            snap_BandHalfWidthTicks,
                            snap_DistToBandEdgeTicks,
                            snap_BeyondBandFlag
                        );

                        File.AppendAllText(tradeLogFile, row);
                    }
                    catch (Exception ex)
                    {
                        Print($"[CSV WRITE ERROR] {ex.Message}");
                    }
                }

                inTrade = false;
                tradeSide = MarketPosition.Flat;
                tradeEntryPrice = 0;
                tradeEntryTime  = DateTime.MinValue;
                currentSetupId = "";
            }
        }

        protected override void OnOrderUpdate(Order order, double limitPrice, double stopPrice, int quantity,
                                              int filled, double averageFillPrice, OrderState orderState,
                                              DateTime time, ErrorCode error, string comment)
        {
            if (order == null || order.Name == null) return;

            if ((orderState == OrderState.Cancelled || orderState == OrderState.Rejected) &&
                (order.Name == "LongEntry" || order.Name == "ShortEntry"))
            {
                string dir = order.Name == "LongEntry" ? "Long" : "Short";
                string reason = BuildOrderReason(order, orderState, error, comment, limitPrice, stopPrice, filled, quantity, averageFillPrice);
                currNonFillReason = reason;

                // compute from snapshots
                double perRiskUSD = snap_StopSizeTicks * TickSize * Instrument.MasterInstrument.PointValue;
                double plannedRiskUSD = perRiskUSD * plannedQty;

                LogSetupEvent(SetupEventType.OrderRejectedOrCancelled, currentSetupId, dir,
                    snap_QualityScore, snap_QS_ATR, snap_QS_Slope, snap_QS_Dist, snap_QS_Stop,
                    snap_AtrTicks, (snap_EmaSlope / TickSize), snap_DistToEmaTicks, snap_StopSizeTicks,
                    perRiskUSD, plannedRiskUSD,
                    triggerPrice, plannedStopPrice, plannedTargetPrice, RewardMultiple, plannedQty,
                    snap_BarsSinceSession, snap_BandHalfWidthTicks, snap_DistToBandEdgeTicks, snap_BeyondBandFlag,
                    snap_Filter_ATR_OK, snap_Filter_Trend_OK, snap_Filter_Band_OK, snap_StopSize_OK,
                    currTriggered, currOrderPlaced, reason, reason);

                DebugMark("REJ", $"{orderState} {dir}", Brushes.Red);
                workingEntry = null;
                armedLong = armedShort = false;
                currentSetupId = "";
            }
        }

        // ===== Quantity & quality helpers =====
        private int CalculateQuantity(double perContractDollarRisk)
        {
            int baseQty = (DollarsRiskPerTrade <= 0 || perContractDollarRisk <= 0)
                ? Math.Max(1, Contracts)
                : (int)Math.Max(1, Math.Round(DollarsRiskPerTrade / perContractDollarRisk));
            return Math.Max(1, Math.Min(baseQty, MaxContracts));
        }

        private static double Clamp(double v, double lo, double hi) => v < lo ? lo : (v > hi ? hi : v);
        private static double Clamp01(double v) => v < 0 ? 0 : (v > 1 ? 1 : v);

        private double QualityScale(double score)
        {
            double t = Clamp((score - QS_Midpoint) / Math.Max(1e-9, (100.0 - QS_Midpoint)), -1.0, 1.0);
            double k = Math.Max(0.1, QS_Curve);
            double s = 0.5 * (1.0 + Math.Tanh(k * t)); // 0..1
            return QS_MinScale + (QS_MaxScale - QS_MinScale) * s;
        }

        private int ComputePlannedQtyWithQS(double perContractDollarRisk, double qualityScore)
        {
            double scale = UseQSSizeModulation ? QualityScale(qualityScore) : 1.0;

            if (DollarsRiskPerTrade <= 0 || !QS_ModulatesRiskBudget)
            {
                int baseQty = (DollarsRiskPerTrade <= 0) ? Math.Max(1, Contracts)
                             : CalculateQuantity(perContractDollarRisk);
                int scaledQty = (int)Math.Max(1, Math.Round(baseQty * scale));
                return Math.Min(scaledQty, MaxContracts);
            }
            else
            {
                double scaledRiskBudget = DollarsRiskPerTrade * scale;
                int qty = (int)Math.Max(1, Math.Round(scaledRiskBudget / Math.Max(1e-9, perContractDollarRisk)));
                return Math.Min(qty, MaxContracts);
            }
        }

        private double ComputeQualityScore(
            double atrTicks,
            double emaSlopeTicksAbs,
            double distToEmaTicks,
            double stopSizeTicks,
            out double qAtr, out double qSlope, out double qDist, out double qStop)
        {
            // ATR sweet-spot around mid of [AtrMinTicks, AtrMaxTicks]
            double atrMin = Math.Max(1.0, AtrMinTicks);
            double atrMax = Math.Max(atrMin + 1.0, AtrMaxTicks);
            double atrMid = 0.5 * (atrMin + atrMax);
            double atrHalfSpan = 0.5 * (atrMax - atrMin);
            qAtr = atrHalfSpan > 0 ? Clamp01(1.0 - Math.Abs(atrTicks - atrMid) / atrHalfSpan) : 1.0;

            // EMA slope saturation
            double slopeRef = Math.Max(0.5, EmaSlopeMinTicks);
            qSlope = Clamp01(1.0 - Math.Exp(-emaSlopeTicksAbs / slopeRef));

            // Distance to EMA (saturate by 2x threshold)
            double distRef = Math.Max(0.5, DistToEmaMinTicks);
            qDist = distToEmaTicks <= 0 ? 0 : Clamp01(distToEmaTicks / (2.0 * distRef));

            // Stop size triangular around ideal
            double ideal = Math.Max(MinStopTicks, StopSizeIdealTicks);
            double maxS  = Math.Max(ideal + 1.0, StopSizeMaxTicks);
            double denom = (maxS - ideal);
            qStop = denom > 0 ? Clamp01(1.0 - Math.Abs(stopSizeTicks - ideal) / denom) : 1.0;

            double wAtr = QS_Weight_ATR, wSlope = QS_Weight_Slope, wDist = QS_Weight_Dist, wStop = QS_Weight_Stop;
            double wSum = Math.Max(1e-6, wAtr + wSlope + wDist + wStop);

            double combined01 = (wAtr * qAtr + wSlope * qSlope + wDist * qDist + wStop * qStop) / wSum;
            return 100.0 * Clamp01(combined01);
        }

        // ===== Visuals =====
        private void DrawStatusLabel()
        {
            if ((DateTime.Now - lastBlinkTime).TotalSeconds >= BlinkSeconds)
            {
                blinkVisible = !blinkVisible;
                lastBlinkTime = DateTime.Now;
            }

            string tag = "MNQRecoverySimple_Status";
            string text;

            if (Position.MarketPosition == MarketPosition.Flat)
            {
                if ((armedLong || armedShort) && blinkVisible)
                {
                    double stopTicksDisp = Math.Abs(triggerPrice - plannedStopPrice) / TickSize;
                    double scaleDisp = UseQSSizeModulation ? QualityScale(snap_QualityScore) : 1.0;

                    text =
                        "ENTRY ARMED\n" +
                        (armedLong ? "Long " : "Short ") +
                        $"Trig:{triggerPrice:F2}  Stop:{plannedStopPrice:F2}  Tgt:{plannedTargetPrice:F2}\n" +
                        $"R:{RewardMultiple:F1}  Qty:{plannedQty}  QS:{snap_QualityScore:F1} x{scaleDisp:F2}\n" +
                        $"StopTicks:{stopTicksDisp:F0} ATRok:{snap_Filter_ATR_OK} TrendOk:{snap_Filter_Trend_OK} Band:{snap_Filter_Band_OK} StopOk:{snap_StopSize_OK} SessBars:{snap_BarsSinceSession}\n" +
                        $"ID:{currentSetupId}";
                }
                else
                    text = " ";
            }
            else
            {
                double entry = Position.AveragePrice;
                double stop = (Position.MarketPosition == MarketPosition.Long)
                    ? crossingCandleLow - Math.Max(StopTicks, MinStopTicks) * TickSize
                    : crossingCandleHigh + Math.Max(StopTicks, MinStopTicks) * TickSize;

                double target = (Position.MarketPosition == MarketPosition.Long)
                    ? entry + (entry - stop) * RewardMultiple
                    : entry - (stop - entry) * RewardMultiple;

                text =
                    (Position.MarketPosition == MarketPosition.Long ? "LONG" : "SHORT") + " ACTIVE\n" +
                    $"Entry:{entry:F2}  Stop:{stop:F2}  Tgt:{target:F2}\n" +
                    $"R:{RewardMultiple:F1}  Qty:{Position.Quantity}  ID:{currentSetupId}";
            }

            Draw.TextFixed(this, tag, text, TextPosition.BottomRight,
                           Brushes.Gainsboro, labelFont,
                           Brushes.Transparent, Brushes.Transparent, 0);
        }

        // ===== Helpers =====
        private string BuildOrderReason(Order order, OrderState orderState, ErrorCode error,
                                        string comment, double limitPrice, double stopPrice,
                                        int filled, int quantity, double averageFillPrice)
        {
            string err  = (error != ErrorCode.NoError ? error.ToString() : "NoError");
            string cmt  = string.IsNullOrWhiteSpace(comment) ? "<none>" : comment.Replace(",", ";").Replace("\r"," ").Replace("\n"," ");
            string name = order?.Name ?? "<null>";
            string state= orderState.ToString();
            return $"State={state} Err={err} Name={name} Comment={cmt} " +
                   $"Lmt={limitPrice:F2} Stp={stopPrice:F2} Filled={filled}/{quantity} Avg={averageFillPrice:F2}";
        }

        private void LogSetupEvent(
            SetupEventType evt, string setupId, string dir, double qScore,
            double qAtr, double qSlope, double qDist, double qStop,
            double atrTicks, double emaSlopeTicks, double distToEmaTicks, double stopSizeTicks,
            double perRiskUSD, double plannedRiskUSD,
            double trig, double stop, double tgt, double r, int qty,
            int barsSinceSess, double bandHalfWidthTicks, double distToBandEdgeTicks, int beyondBandFlag,
            int atrOk, int trendOk, int bandOk, int stopOk,
            int triggered, int orderPlaced, string nonFillReason,
            string notes = "")
        {
            if (!csvEnabled) return;

            try
            {
                var safeNotes = (notes ?? string.Empty)
                    .Replace("\r", " ").Replace("\n", " ").Replace(",", ";").Replace("\"", "'");
                var safeReason = (nonFillReason ?? string.Empty)
                    .Replace("\r", " ").Replace("\n", " ").Replace(",", ";").Replace("\"", "'");

                string row = string.Format(CultureInfo.InvariantCulture,
                    "{0},{1},{2},{3},{4},{5},{6:F1},{7:F2},{8:F2},{9:F2},{10:F2},{11:F2},{12:F2},{13:F2},{14:F1},{15:F2},{16:F2},{17:F2},{18:F2},{19:F2},{20:F1},{21}," +
                    "{22},{23},{24},{25},{26},{27:F2},{28:F2},{29},{30},{31},{32},{33},{34},{35},\"{36}\",\"{37}\"\n",
                    Time[0].ToString("yyyy-MM-dd"),
                    Time[0].ToString("HH:mm:ss"),
                    CurrentBar,
                    setupId ?? string.Empty,
                    evt,
                    dir ?? string.Empty,
                    qScore,
                    qAtr, qSlope, qDist, qStop,
                    atrTicks,
                    emaSlopeTicks,
                    distToEmaTicks,
                    stopSizeTicks,
                    perRiskUSD,
                    plannedRiskUSD,
                    trig, stop, tgt, r, qty,
                    UseTimeFilter ? StartTime.ToString() : "NA",
                    UseTimeFilter ? EndTime.ToString()   : "NA",
                    UseTimeFilter ? ExcludeStart.ToString() : "NA",
                    UseTimeFilter ? ExcludeEnd.ToString()   : "NA",
                    barsSinceSess,
                    bandHalfWidthTicks,
                    distToBandEdgeTicks,
                    beyondBandFlag,
                    atrOk, trendOk, bandOk, stopOk,
                    triggered, orderPlaced, safeReason, safeNotes
                );

                File.AppendAllText(setupLogFile, row);
            }
            catch (Exception ex)
            {
                Print($"[CSV WRITE ERROR - SETUPS] {ex.Message}");
            }
        }

        private string NewSetupId(string dir)
        {
            setupSeq++;
            return $"{Time[0]:yyyy-MM-dd_HH-mm-ss}_{(dir.StartsWith("L") ? "L" : "S")}_{setupSeq:D5}";
        }
    }
}
