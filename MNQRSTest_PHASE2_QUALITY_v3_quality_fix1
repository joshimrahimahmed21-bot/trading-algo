
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.IO;
using System.Text;
using System.Windows;
using System.Windows.Media;
using NinjaTrader.Cbi;
using NinjaTrader.Data;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Gui.Tools;
using NinjaTrader.NinjaScript;
using NinjaTrader.NinjaScript.DrawingTools;
using NinjaTrader.NinjaScript.Indicators;
#endregion

namespace NinjaTrader.NinjaScript.Strategies
{
    public class MNQRSTest : Strategy
    {
        // ===========================
        // PARAMETERS
        // ===========================
        #region Parameters
        // --- Filters & Space ---
        [NinjaScriptProperty, Display(Name="UseSpaceFilter", GroupName="Filters", Order=0)]
        public bool UseSpaceFilter { get; set; } = true;

        [NinjaScriptProperty, Range(0.0, double.MaxValue), Display(Name="MinSpaceR", GroupName="Filters", Order=1)]
        public double MinSpaceR { get; set; } = 0.80;

        [NinjaScriptProperty, Display(Name="UseRZoneIgnore", GroupName="Filters", Order=2)]
        public bool UseRZoneIgnore { get; set; } = true;

        [NinjaScriptProperty, Range(0.0, 2.0), Display(Name="RZoneIgnoreBelowR", GroupName="Filters", Order=3)]
        public double RZoneIgnoreBelowR { get; set; } = 0.50;

        [NinjaScriptProperty, Range(0.0, 100.0), Display(Name="MinAbsSpaceTicks", GroupName="Filters", Order=4)]
        public double MinAbsSpaceTicks { get; set; } = 2.0;

        [NinjaScriptProperty, Display(Name="GateAbsByTrend", GroupName="Filters", Order=5)]
        public bool GateAbsByTrend { get; set; } = true;

        [NinjaScriptProperty, Display(Name="GateAbsSoftTier", GroupName="Filters", Order=6)]
        public bool GateAbsSoftTier { get; set; } = true;

        [NinjaScriptProperty, Range(1, 200), Display(Name="SpaceLookback", GroupName="Filters", Order=7)]
        public int SpaceLookback { get; set; } = 8;

        [NinjaScriptProperty, Range(0, 50), Display(Name="SpaceIgnoreBars", GroupName="Filters", Order=8)]
        public int SpaceIgnoreBars { get; set; } = 3;

        [NinjaScriptProperty, Display(Name="UseAtrBuffer", GroupName="Filters", Order=9)]
        public bool UseAtrBuffer { get; set; } = true;

        [NinjaScriptProperty, Range(0.0, 20.0), Display(Name="AtrBufferTicks", GroupName="Filters", Order=10)]
        public double AtrBufferTicks { get; set; } = 2.0;

        // --- Trend awareness ---
        [NinjaScriptProperty, Range(1, 1000), Display(Name="TrendSlopeLookback", GroupName="Trend", Order=0)]
        public int TrendSlopeLookback { get; set; } = 5;

        [NinjaScriptProperty, Range(0.0, 100.0), Display(Name="TrendSlopeMinTicks", GroupName="Trend", Order=1)]
        public double TrendSlopeMinTicks { get; set; } = 2.0;

        [NinjaScriptProperty, Display(Name="UseTrendAwareSpace", GroupName="Trend", Order=2)]
        public bool UseTrendAwareSpace { get; set; } = true;

        [NinjaScriptProperty, Range(0.0, 2.0), Display(Name="TrendMinSpaceR", GroupName="Trend", Order=3)]
        public double TrendMinSpaceR { get; set; } = 0.80;

        // --- Behavior ---
        [NinjaScriptProperty, Range(1, 1000), Display(Name="SetupExpiryBars", GroupName="Behavior", Order=0)]
        public int SetupExpiryBars { get; set; } = 10;

        [NinjaScriptProperty, Range(0.0, 10.0), Display(Name="SmallCandleThreshold", GroupName="Behavior", Order=1)]
        public double SmallCandleThreshold { get; set; } = 0.8;

        // --- Time ---
        [NinjaScriptProperty, Display(Name="UseTimeFilter", GroupName="Time", Order=0)]
        public bool UseTimeFilter { get; set; } = true;

        [NinjaScriptProperty, Range(0, 235959), Display(Name="SessionStart", GroupName="Time", Order=1)]
        public int SessionStart { get; set; } = 93000;

        [NinjaScriptProperty, Range(0, 235959), Display(Name="SessionEnd", GroupName="Time", Order=2)]
        public int SessionEnd { get; set; } = 160000;

        // --- Session anchors & shape ---
        [NinjaScriptProperty, Display(Name="UseSessionAnchor", GroupName="Session", Order=0)]
        public bool UseSessionAnchor { get; set; } = true;

        [NinjaScriptProperty, Range(0,23), Display(Name="AnchorHour", GroupName="Session", Order=1)]
        public int AnchorHour { get; set; } = 13;

        [NinjaScriptProperty, Range(0,59), Display(Name="AnchorMinute", GroupName="Session", Order=2)]
        public int AnchorMinute { get; set; } = 30;

        [NinjaScriptProperty, Range(1,240), Display(Name="AnchorWindowMins", GroupName="Session", Order=3)]
        public int AnchorWindowMins { get; set; } = 20;

        [NinjaScriptProperty, Range(0.0,1.0), Display(Name="SessionPenalty", GroupName="Session", Order=4)]
        public double SessionPenalty { get; set; } = 0.25;

        [NinjaScriptProperty, Display(Name="SessionReversalBias", GroupName="Session", Order=5)]
        public bool SessionReversalBias { get; set; } = true;

        [NinjaScriptProperty, Display(Name="UseAnchor2", GroupName="Session", Order=6)]
        public bool UseAnchor2 { get; set; } = false;
        [NinjaScriptProperty, Range(0,23), Display(Name="Anchor2Hour", GroupName="Session", Order=7)]
        public int Anchor2Hour { get; set; } = 15;
        [NinjaScriptProperty, Range(0,59), Display(Name="Anchor2Minute", GroupName="Session", Order=8)]
        public int Anchor2Minute { get; set; } = 30;

        [NinjaScriptProperty, Display(Name="UseAnchor3", GroupName="Session", Order=9)]
        public bool UseAnchor3 { get; set; } = false;
        [NinjaScriptProperty, Range(0,23), Display(Name="Anchor3Hour", GroupName="Session", Order=10)]
        public int Anchor3Hour { get; set; } = 10;
        [NinjaScriptProperty, Range(0,59), Display(Name="Anchor3Minute", GroupName="Session", Order=11)]
        public int Anchor3Minute { get; set; } = 0;

        [NinjaScriptProperty, Display(Name="SessionWindowShape", GroupName="Session", Order=12)]
        public string SessionWindowShape { get; set; } = "Gaussian";

        [NinjaScriptProperty, Range(0.0,2.0), Display(Name="PreScale", GroupName="Session", Order=13)]
        public double PreScale { get; set; } = 1.0;

        [NinjaScriptProperty, Range(0.0,2.0), Display(Name="PostScale", GroupName="Session", Order=14)]
        public double PostScale { get; set; } = 1.0;

// --- Swing / context ---
[NinjaScriptProperty]
[Display(Name="UseSwingOnly", GroupName="Context", Order=0)]
public bool UseSwingOnly { get; set; } = true;

[NinjaScriptProperty]
[Range(1, 10)]
[Display(Name="SwingStrength", GroupName="Context", Order=1)]
public int SwingStrength { get; set; } = 3;


        // --- Quality weights (telemetry) ---
        [NinjaScriptProperty, Display(Name="LogQualityTelemetry", GroupName="Quality", Order=0)]
        public bool LogQualityTelemetry { get; set; } = true;

        [NinjaScriptProperty, Range(0.0,1.0), Display(Name="W_Space", GroupName="Quality", Order=1)]
        public double W_Space { get; set; } = 0.60;

        [NinjaScriptProperty, Range(0.0,1.0), Display(Name="W_Trend", GroupName="Quality", Order=2)]
        public double W_Trend { get; set; } = 0.20;

        [NinjaScriptProperty, Range(0.0,1.0), Display(Name="W_Session", GroupName="Quality", Order=3)]
        public double W_Session { get; set; } = 0.20;

        [NinjaScriptProperty, Range(0.0,1.0), Display(Name="W_Swing", GroupName="Quality", Order=4)]
        public double W_Swing { get; set; } = 0.15;

        [NinjaScriptProperty, Range(0.0,1.0), Display(Name="W_Momo", GroupName="Quality", Order=5)]
        public double W_Momo { get; set; } = 0.15;

        [NinjaScriptProperty, Range(0.0,1.0), Display(Name="W_Vol", GroupName="Quality", Order=6)]
        public double W_Vol { get; set; } = 0.10;

        [NinjaScriptProperty, Range(0.0,1.0), Display(Name="MinBodyPct", GroupName="Quality", Order=10)]
        public double MinBodyPct { get; set; } = 0.25;

        [NinjaScriptProperty, Display(Name="VolLow", GroupName="Quality", Order=11)]
        public double VolLow { get; set; } = 0.4;

        [NinjaScriptProperty, Display(Name="VolHigh", GroupName="Quality", Order=12)]
        public double VolHigh { get; set; } = 1.6;

        [NinjaScriptProperty, Display(Name="WickDomThresh", GroupName="Quality", Order=13)]
        public double WickDomThresh { get; set; } = 1.2;

        [NinjaScriptProperty, Display(Name="WickBonus", GroupName="Quality", Order=14)]
        public double WickBonus { get; set; } = 0.05;

        // --- Quality gating / sizing (placeholders; gate OFF by default) ---
        [NinjaScriptProperty, Display(Name="UseQualityGate", GroupName="Quality", Order=100)]
        public bool UseQualityGate { get; set; } = false;

        [NinjaScriptProperty, Display(Name="UseQualitySizing", GroupName="Quality", Order=101)]
        public bool UseQualitySizing { get; set; } = false;

        [NinjaScriptProperty, Range(0.0, 1.0), Display(Name="MinQTotal2", GroupName="Quality", Order=102)]
        public double MinQTotal2 { get; set; } = 0.55;

        [NinjaScriptProperty, Range(0.0, 1.0), Display(Name="QTotal2SizeThreshold", GroupName="Quality", Order=103)]
        public double QTotal2SizeThreshold { get; set; } = 0.65;

        [NinjaScriptProperty, Range(0.1, 10.0), Display(Name="SizeFactorLow", GroupName="Quality", Order=104)]
        public double SizeFactorLow { get; set; } = 0.5;

        // --- Risk ---
        [NinjaScriptProperty, Range(1, 100), Display(Name="BaseQty", GroupName="Risk", Order=0)]
        public int BaseQty { get; set; } = 1;
        #endregion

        // ===========================
        // INTERNALS
        // ===========================
        private EMA ema;
        private int EmaPeriod = 20;
        private int EntryTicks = 1;
        private int StopTicks = 45;
        private int MinStopTicks = 10;
        private double RewardMultiple = 1.0;

        private int StartTime = 93000;   // mirrors SessionStart
        private int EndTime   = 160000;  // mirrors SessionEnd
        private int ExcludeStart = 0;
        private int ExcludeEnd   = 0;

        private int setupBarIndex = -1;
        private double crossingCandleHigh;
        private double crossingCandleLow;
        private double triggerPrice;
        private double plannedStopPrice;
        private double plannedTargetPrice;
        private bool armedLong = false;
        private bool armedShort = false;
        private int plannedQty = 1;

// Quality cache for current setup (used when arming/placing orders)
private double lastQSpace = 1.0, lastQTrend = 1.0, lastQSession = 1.0, lastQTotal = 1.0, lastQTotal2 = 1.0;
private int lastPlannedQty = 1;

// Added Phase-2: per-trade quality cache for logging
private double lastQSwing = 0.0, lastQMomo = 0.0, lastQVol = 0.0;



        private Series<double> candleRange;
        private int barsSinceSessionOpen = 0;
        private int debugMarksCount = 0;
        private bool inTrade = false;
        private MarketPosition tradeSide = MarketPosition.Flat;
        private double tradeEntryPrice = 0;
        private DateTime tradeEntryTime = DateTime.MinValue;

        private string runStamp = null;
        private string setupLogPath;
        private string tradeLogPath;
        private bool logsReady = false;

        private SimpleFont hudFont = new SimpleFont("Segoe UI", 13) { Bold = true };
        // Momentum tracking while armed
        private double maeTicksWhileArmed = 0.0;
        private double maeRefPrice = 0.0;


        private struct SpaceCheckResult
        {
            public bool Pass;
            public double Rmultiple;
            public double RawNearTicks;
            public double AdjNearTicks;
            public double RiskTicks;
        }

        // ===========================
        // STATE
        // ===========================
        protected override void OnStateChange()
        {
            if (State == State.SetDefaults)
            {
                Description = "MNQ EMA-cross + space filter + session telemetry + CSV logs";
                Name = "MNQRSTest";
                Calculate = Calculate.OnBarClose;
                EntriesPerDirection = 1;
                EntryHandling = EntryHandling.AllEntries;
                IsExitOnSessionCloseStrategy = false;
                ExitOnSessionCloseSeconds = 30;
                IsInstantiatedOnEachOptimizationIteration = true;
            }
            else if (State == State.Configure)
            {
                AddDataSeries(BarsPeriodType.Minute, 1);
            }
            else if (State == State.DataLoaded)
            {
                ema = EMA(EmaPeriod);
                AddChartIndicator(ema);
                candleRange = new Series<double>(this);

                runStamp = DateTime.Now.ToString("yyyyMMdd_HHmmss");
                string runDir = Path.Combine(Core.Globals.UserDataDir, "strategies", Name, runStamp);
                try { Directory.CreateDirectory(runDir); } catch { }
                Print("[MNQRSTest] Run folder: " + runDir);
                Print("[MNQ BUILD] INTEGRATED_QUALITY_V1 " + DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss"));
                Print("[MNQ BUILD] SESSION_SHAPES v1");
            }
        }

        // ===========================
        // ---- Quality helper functions ----
// ensure present

        private double GetLastSwingHigh(int lookback, int strength)
        {
            double best = double.MinValue;
            for (int i = 1; i <= lookback && CurrentBar - i - strength >= 0; i++)
            {
                bool isSwingHigh = High[i] == MAX(High, strength)[i];
                if (isSwingHigh && High[i] >= best) best = High[i];
            }
            return best == double.MinValue ? High[0] : best;
        }

        private double GetLastSwingLow(int lookback, int strength)
        {
            double best = double.MaxValue;
            for (int i = 1; i <= lookback && CurrentBar - i - strength >= 0; i++)
            {
                bool isSwingLow = Low[i] == MIN(Low, strength)[i];
                if (isSwingLow && Low[i] <= best) best = Low[i];
            }
            return best == double.MaxValue ? Low[0] : best;
        }

        private double CrossingBodyPct(int idx)
        {
            double h = High[idx], l = Low[idx], o = Open[idx], c = Close[idx];
            double range = Math.Max(Instrument.MasterInstrument.TickSize, h - l);
            return Math.Min(1.0, Math.Abs(c - o) / range);
        }

        private double WickDominanceBonus(bool isLong, int idx)
        {
            double h = High[idx], l = Low[idx], o = Open[idx], c = Close[idx];
            double body = Math.Max(Instrument.MasterInstrument.TickSize, Math.Abs(c - o));
            double upper = h - Math.Max(o, c);
            double lower = Math.Min(o, c) - l;
            double ratioUpper = upper / body;
            double ratioLower = lower / body;
            bool goodLong  = isLong  && (ratioLower > WickDomThresh);
            bool goodShort = !isLong && (ratioUpper > WickDomThresh);
            return (goodLong || goodShort) ? WickBonus : 0.0;
        }

        private double ComputeQ_Vol()
        {
            double atr = ATR(14)[0];
            if (atr <= 0) return 0.5;
            double rng = High[0] - Low[0];
            double ratio = rng / atr;
            if (ratio <= VolLow * 0.5 || ratio >= VolHigh * 2.0) return 0.0;
            double left  = (ratio - VolLow * 0.5) / Math.Max(1e-6, VolLow * 0.5);
            double mid   = 1.0 - Math.Abs(ratio - 1.0) / Math.Max(1e-6, (1.0 - VolLow));
            double right = (VolHigh * 2.0 - ratio) / Math.Max(1e-6, VolHigh);
            double q = Math.Min(1.0, Math.Max(0.0, Math.Min(Math.Min(left, right), mid)));
            return q;
        }

        private double ComputeQ_Momo(bool isLong, double riskTicks)
        {
            double tick = Instrument.MasterInstrument.TickSize;
            double slopeTicks = Math.Abs(ema[0] - ema[TrendSlopeLookback]) / tick;
            double q_slope = Clamp01(slopeTicks / Math.Max(1.0, TrendSlopeMinTicks));

            double bodyPct = CrossingBodyPct(0);
            double q_body = Clamp01((bodyPct - MinBodyPct) / Math.Max(0.10, 1.0 - MinBodyPct));

            double q_mae = 1.0 - Clamp01(maeTicksWhileArmed / Math.Max(1.0, riskTicks));

            double bonus = WickDominanceBonus(isLong, 0);
            double q = Clamp01(0.4 * q_slope + 0.3 * q_body + 0.3 * q_mae + bonus);
            return q;
        }

        private double ComputeQ_Swing(bool isLong, double riskTicks)
        {
            double tick = Instrument.MasterInstrument.TickSize;
            double lastHigh = GetLastSwingHigh(20, SwingStrength);
            double lastLow  = GetLastSwingLow(20, SwingStrength);
            double breakTicks = isLong
                ? Math.Max(0.0, (Close[0] - lastHigh) / tick)
                : Math.Max(0.0, (lastLow - Close[0]) / tick);
            double q_break = Clamp01(riskTicks > 0 ? (breakTicks / riskTicks) : 0.0);

            // compact range bonus
            int rangeLb = 12;
            double hi = MAX(High, rangeLb)[0];
            double lo = MIN(Low,  rangeLb)[0];
            double bandTicks = (hi - lo) / tick;
            double atrTicks  = ATR(14)[0] / tick;
            double range_compact = 1.0 - Clamp01(bandTicks / Math.Max(1.0, atrTicks * 1.0));

            return Clamp01(0.75 * q_break + 0.25 * range_compact);
        }
        // HELPERS
        // ===========================
        private void DPrint(string msg, int level = 1) { Print(msg); }

        private void EnsureLogsInitialized()
        {
            if (logsReady) return;

            string logDir = (runStamp != null)
                ? Path.Combine(Core.Globals.UserDataDir, "strategies", Name, runStamp)
                : Path.Combine(Core.Globals.UserDataDir, "strategies", Name);
            try { Directory.CreateDirectory(logDir); } catch { }

            string setupName = "MNQRSTest_Setups_" + runStamp + ".csv";
            string tradeName = "MNQRSTest_Trades_" + runStamp + ".csv";
            setupLogPath = Path.Combine(logDir, setupName);
            tradeLogPath = Path.Combine(logDir, tradeName);

            using (var sw = new StreamWriter(setupLogPath, false))
            {
                sw.WriteLine("Date,Time,Bar,Event,Side,Why,Trigger,Stop,Target,R,StopTicks,ATR?,Notes");
                var cfg = BuildParamEcho();
                var cfgLine = string.Format("#CONFIG,{0},,Params,,,,,,,{1},{2}",
                    DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss"),
                    (UseAtrBuffer ? 1 : 0),
                    cfg);
                sw.WriteLine(cfgLine);
            }
            using (var tw = new StreamWriter(tradeLogPath, false))
            {
                tw.WriteLine("Date,Time,Side,Entry,Stop,Target,R,Qty,Exit,PLTicks,PLUSD,ExitType,Q_Swing,Q_Momo,Q_Vol,QSession,QTotal2");
                var cfg = BuildParamEcho();
                var tcols = new string[] { "#CONFIG", DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss"), "Params", "", "", "", "", "", "", "", "", cfg };
                tw.WriteLine(string.Join(",", tcols));
            }
            logsReady = true;
            Print("[MNQ PARAMS] " + BuildParamEcho());
        }

        private void LogSetupRow(string evt, string side, string why,
                                 double trig, double stp, double tgt, double r,
                                 double stopTicks, string notes = "")
        {
            if (!logsReady) return;
            var row = string.Format("{0},{1},{2},{3},{4},{5},{6:F2},{7:F2},{8:F2},{9:F2},{10:F1},{11},{12}\n",
                Time[0].ToString("yyyy-MM-dd"),
                Time[0].ToString("HH:mm:ss"),
                CurrentBar,
                evt,
                side,
                (why ?? ""),
                trig, stp, tgt, r, stopTicks,
                "", // ATR? placeholder
                (notes ?? "").Replace(",", ";")
            );
            File.AppendAllText(setupLogPath, row);
        }

private void LogTradeRow(string side, double entry, double stp, double tgt, double r,
                         int qty, double exit, double plTicks, double plUsd, string exitType)
{
    if (!logsReady) return;
    var row = string.Format("{0},{1},{2},{3:F2},{4:F2},{5:F2},{6:F2},{7},{8:F2},{9:F1},{10:F2},{11},{12:F2},{13:F2},{14:F2},{15:F2},{16:F2}\n",
        Time[0].ToString("yyyy-MM-dd"),
        Time[0].ToString("HH:mm:ss"),
        side,
        entry, stp, tgt, r, qty,
        exit, plTicks, plUsd, exitType,
        lastQSwing, lastQMomo, lastQVol, lastQSession, lastQTotal2
    );
    File.AppendAllText(tradeLogPath, row);
}

        private SpaceCheckResult CheckSpaceFilter(bool isLong, double entryPrice, double stopPrice, int lookback)
        {
            SpaceCheckResult res = new SpaceCheckResult { Pass = true, Rmultiple = 999 };
            double risk = Math.Abs(entryPrice - stopPrice);
            if (risk <= 0) { res.Pass = false; res.Rmultiple = 0; return res; }

            double nearestDist = double.MaxValue;
            for (int i = Math.Max(1, SpaceIgnoreBars); i <= lookback && (CurrentBar - i) >= 0; i++)
            {
                if (isLong)
                {
                    if (High[i] > entryPrice) nearestDist = Math.Min(nearestDist, High[i] - entryPrice);
                }
                else
                {
                    if (Low[i] < entryPrice) nearestDist = Math.Min(nearestDist, entryPrice - Low[i]);
                }
            }
            if (nearestDist == double.MaxValue) nearestDist = risk;

            double atrBuf = UseAtrBuffer ? AtrBufferTicks * Instrument.MasterInstrument.TickSize : 0.0;
            double rawNear = nearestDist;
            double adjNear = Math.Max(0.0, rawNear - atrBuf);
            double ignore = (UseRZoneIgnore ? RZoneIgnoreBelowR : 0.0) * risk;
            double effNear = Math.Max(0.0, adjNear - ignore);
            double rMultiple = effNear / risk;

            res.Rmultiple = rMultiple;
            res.RawNearTicks = rawNear / Instrument.MasterInstrument.TickSize;
            res.AdjNearTicks = adjNear / Instrument.MasterInstrument.TickSize;
            res.RiskTicks = risk / Instrument.MasterInstrument.TickSize;
            res.Pass = rMultiple >= MinSpaceR;
            return res;
        }

        // ---- Session helpers ----
        private static double Clamp01(double x) { return x < 0 ? 0 : (x > 1 ? 1 : x); }
        private double MinutesBetween(double a, double b) { double d = Math.Abs(a - b); return Math.Min(d, 1440.0 - d); }
        private double ProxGaussian(double deltaM, double windowMins) { double sigma = Math.Max(1.0, windowMins/2.0); return Math.Exp(-(deltaM*deltaM)/(2.0*sigma*sigma)); }
        private double ProxTriangular(double deltaM, double windowMins) { if (deltaM >= windowMins) return 0.0; return 1.0 - (deltaM / windowMins); }
        private double ProxCosine(double deltaM, double windowMins) { if (deltaM >= windowMins) return 0.0; double x = deltaM / windowMins; return 0.5*(1.0 + Math.Cos(Math.PI * x)); }
        private double MinutesToNearestAnchor(out int aHour, out int aMinute, out int aIndex)
        {
            double now = Time[0].TimeOfDay.TotalMinutes;
            double best = double.MaxValue; int bestH = AnchorHour, bestM = AnchorMinute, bestIdx = 1;
            double m1 = AnchorHour*60.0 + AnchorMinute; double d1 = MinutesBetween(now, m1); best=d1;
            if (UseAnchor2) { double m2 = Anchor2Hour*60.0 + Anchor2Minute; double d2 = MinutesBetween(now, m2); if (d2 < best) { best=d2; bestH=Anchor2Hour; bestM=Anchor2Minute; bestIdx=2; } }
            if (UseAnchor3) { double m3 = Anchor3Hour*60.0 + Anchor3Minute; double d3 = MinutesBetween(now, m3); if (d3 < best) { best=d3; bestH=Anchor3Hour; bestM=Anchor3Minute; bestIdx=3; } }
            aHour = bestH; aMinute = bestM; aIndex = bestIdx; return best;
        }
        private double SessionProximity(double deltaM, out string shapeUsed)
        {
            string shape = (SessionWindowShape ?? "Gaussian").Trim(); shapeUsed = shape;
            if (string.Equals(shape, "Triangular", StringComparison.OrdinalIgnoreCase)) return ProxTriangular(deltaM, AnchorWindowMins);
            if (string.Equals(shape, "Cosine", StringComparison.OrdinalIgnoreCase))     return ProxCosine(deltaM, AnchorWindowMins);
            shapeUsed = "Gaussian"; return ProxGaussian(deltaM, AnchorWindowMins);
        }
        private void AppendSessionNotes(ref string extraNotes, double qSession, double deltaM, int anchorH, int anchorM, string shapeUsed, int anchorIdx, double qTotal2)
        {
            var sb = new StringBuilder(128);
            sb.Append(";QSession=").Append(qSession.ToString("F2"));
            sb.Append(";DeltaM=").Append(deltaM.ToString("F0"));
            sb.Append(";Anchor=").Append(anchorH.ToString("D2")).Append(":").Append(anchorM.ToString("D2"));
            sb.Append(";Shape=").Append(shapeUsed);
            sb.Append(";Active=").Append(anchorIdx.ToString());
            sb.Append(";QTotal2=").Append(qTotal2.ToString("F2"));
            extraNotes += sb.ToString();
        }

        private double EffectiveMinSpaceR()
        {
            double minR = MinSpaceR;
            if (UseTrendAwareSpace && CurrentBar > TrendSlopeLookback)
            {
                double slopeTicks = Math.Abs(ema[0] - ema[TrendSlopeLookback]) / Instrument.MasterInstrument.TickSize;
                if (slopeTicks >= TrendSlopeMinTicks) minR = Math.Min(minR, TrendMinSpaceR);
            }
            return minR;
        }
private void ComputeQuality(bool isLong,
                            double minSpaceEff,
                            SpaceCheckResult space,
                            out double qSpace, out double qTrend, out double qSession,
                            out double qTotal, out double qTotal2,
                            out string extra)
{
    double r_rel = space.RiskTicks > 0 ? (space.AdjNearTicks / space.RiskTicks) : 0.0;
    qSpace = (space.RawNearTicks >= MinAbsSpaceTicks)
             ? Math.Min(1.0, (minSpaceEff > 0 ? r_rel / minSpaceEff : 1.0))
             : 0.0;

    double emaSlopeTicks = Math.Abs(ema[0] - ema[TrendSlopeLookback]) / Instrument.MasterInstrument.TickSize;
    qTrend = Math.Min(1.0, emaSlopeTicks / Math.Max(1.0, TrendSlopeMinTicks));

    double deltaM = 0.0; int aH=AnchorHour, aM=AnchorMinute, aIdx=1; string shapeUsed="Gaussian";
    qSession = 1.0;
    if (UseSessionAnchor)
    {
        deltaM = MinutesToNearestAnchor(out aH, out aM, out aIdx);
        double proximity = SessionProximity(deltaM, out shapeUsed);
        double nowM = Time[0].TimeOfDay.TotalMinutes;
        double aMin = aH*60.0 + aM;
        bool isPost = ((nowM - aMin + 1440.0) % 1440.0) <= 720.0 ? (nowM >= aMin) : (nowM < aMin);
        double asym = isPost ? PostScale : PreScale;
        bool withTrend = isLong ? (ema[0] > ema[TrendSlopeLookback]) : (ema[0] < ema[TrendSlopeLookback]);
        double adj = SessionPenalty * asym * proximity;
        qSession = Clamp01(SessionReversalBias ? (withTrend ? (1.0 - adj) : (1.0 + 0.25 * adj)) : (1.0 - adj));
    }

    
    double tick = Instrument.MasterInstrument.TickSize;
    double riskTicks_here = Math.Max(1.0, Math.Abs(plannedStopPrice - triggerPrice) / tick);
    double qSwing = ComputeQ_Swing(isLong, riskTicks_here);
    double qMomo  = ComputeQ_Momo(isLong, riskTicks_here);
    double qVol   = ComputeQ_Vol();

    qTotal  = Clamp01(W_Space*qSpace + W_Trend*qTrend + W_Swing*qSwing + W_Momo*qMomo + W_Vol*qVol);
    qTotal2 = Clamp01(qTotal + W_Session*qSession);

    
// Cache detailed quality components for trade logging
lastQSwing = qSwing;
lastQMomo  = qMomo;
lastQVol   = qVol;
lastQSession = qSession;
lastQTotal   = qTotal;
lastQTotal2  = qTotal2;
extra = string.Empty;
    if (LogQualityTelemetry)
    {
        AppendSessionNotes(ref extra, qSession, deltaM, aH, aM, shapeUsed, aIdx, qTotal2);
        extra += string.Format(";QSpace={0:F2};QTrend={1:F2};QSwing={2:F2};QMomo={3:F2};QVol={4:F2};QTotal={5:F2}", qSpace, qTrend, qSwing, qMomo, qVol, qTotal);
        extra += ";QSwing=0.00;QMomo=0.00;QVol=0.00";
    }
}


        // ===========================
        // MAIN LOOP
        // ===========================
        protected override void OnBarUpdate()
        {
            if (CurrentBar < Math.Max(50, TrendSlopeLookback+1)) return;

            if (UseTimeFilter)
            {
                int t = ToTime(Time[0]);
                if (t < SessionStart || t > SessionEnd)
                {
                    armedLong = armedShort = false;
                    return;
                }
            }

            EnsureLogsInitialized();
            // Update MAE while armed
            if (armedLong || armedShort)
            {
                double adverse = armedLong
                    ? Math.Max(0.0, (maeRefPrice - Low[0]) / Instrument.MasterInstrument.TickSize)
                    : Math.Max(0.0, (High[0] - maeRefPrice) / Instrument.MasterInstrument.TickSize);
                if (adverse > maeTicksWhileArmed) maeTicksWhileArmed = adverse;
            }


            // Track session
            if (Bars.IsFirstBarOfSession) { barsSinceSessionOpen = 0; debugMarksCount = 0; }
            else barsSinceSessionOpen++;

            // Small candle context
            if (candleRange == null) candleRange = new Series<double>(this);
            candleRange[0] = High[0] - Low[0];
            double avgRange = SMA(candleRange, 20)[0];
            bool smallCandle = avgRange > 0 && candleRange[0] < SmallCandleThreshold * avgRange;

            double ema0 = ema[0], ema1 = ema[1];

            if (!armedLong && !armedShort && smallCandle)
            {
                // ===== SHORT (bearish cross) =====
                if (Close[1] > ema1 && Close[0] < ema0)
                {
                    crossingCandleHigh = High[0];
                    crossingCandleLow  = Low[0];
                    setupBarIndex = CurrentBar;

                    triggerPrice       = crossingCandleLow - EntryTicks * Instrument.MasterInstrument.TickSize;
                    plannedStopPrice   = crossingCandleHigh + StopTicks * Instrument.MasterInstrument.TickSize;
                    plannedTargetPrice = triggerPrice - (plannedStopPrice - triggerPrice) * RewardMultiple;

                    if (UseSpaceFilter)
                    {
                        var space = CheckSpaceFilter(false, triggerPrice, plannedStopPrice, SpaceLookback);
                        double minSpace = EffectiveMinSpaceR();
                        minSpace = UseRZoneIgnore ? Math.Max(0.0, minSpace - RZoneIgnoreBelowR) : minSpace;

                        double targetTicks = Math.Abs(plannedTargetPrice - triggerPrice) / Instrument.MasterInstrument.TickSize;
                        double emaSlopeTicks_local = Math.Abs(ema[0] - ema[TrendSlopeLookback]) / Instrument.MasterInstrument.TickSize;
                        bool trendOK_local = !GateAbsByTrend ? true : (emaSlopeTicks_local >= Math.Max(1.0, TrendSlopeMinTicks));
                        int softExtra_local = (GateAbsSoftTier && emaSlopeTicks_local < Math.Max(1.0, TrendSlopeMinTicks)) ? 1 : 0;
                        bool passByAbs = (space.RawNearTicks >= (MinAbsSpaceTicks + softExtra_local)) && (!GateAbsByTrend || trendOK_local);
                        bool passByBeyondTarget = space.RawNearTicks >= targetTicks;

                        if (!(passByAbs || passByBeyondTarget) && space.Rmultiple < minSpace)
                        {
                            string extraNotes = string.Empty;
                            if (LogQualityTelemetry)
                            {
                                double emaSlopeTicks = emaSlopeTicks_local;
                                double r_rel = space.RiskTicks > 0 ? (space.AdjNearTicks / space.RiskTicks) : 0.0;
                                double qSpace = (space.RawNearTicks >= MinAbsSpaceTicks) ? Math.Min(1.0, (minSpace > 0 ? r_rel / minSpace : 1.0)) : 0.0;
                                double qTrend = Math.Min(1.0, emaSlopeTicks / Math.Max(1.0, TrendSlopeMinTicks));

                                double deltaM = 0.0; int aH=AnchorHour, aM=AnchorMinute, aIdx=1; string shapeUsed="Gaussian";
                                double qSession = 1.0;
                                if (UseSessionAnchor)
                                {
                                    deltaM = MinutesToNearestAnchor(out aH, out aM, out aIdx);
                                    double proximity = SessionProximity(deltaM, out shapeUsed);
                                    double nowM = Time[0].TimeOfDay.TotalMinutes;
                                    double aMin = aH*60.0 + aM;
                                    bool isPost = ((nowM - aMin + 1440.0) % 1440.0) <= 720.0 ? (nowM >= aMin) : (nowM < aMin);
                                    double asym = isPost ? PostScale : PreScale;
                                    bool withTrend = (ema[0] < ema[TrendSlopeLookback]);
                                    double adj = SessionPenalty * asym * proximity;
                                    qSession = Clamp01(SessionReversalBias ? (withTrend ? (1.0 - adj) : (1.0 + 0.25 * adj)) : (1.0 - adj));
                                }
                                double qTotal = Clamp01(W_Space * qSpace + W_Trend * qTrend);
                                double qTotal2 = Clamp01(qTotal + W_Session * (UseSessionAnchor ? 1.0 : 0.0) * (UseSessionAnchor ? 1.0 : 0.0)); // keep form

                                AppendSessionNotes(ref extraNotes, qSession, deltaM, aH, aM, shapeUsed, aIdx, qTotal2);
                                extraNotes += string.Format(";QSpace={0:F2};QTrend={1:F2};QTotal={2:F2}", qSpace, qTrend, qTotal);
                            }
                            extraNotes += ";AbsTrendOK=" + (trendOK_local ? "1" : "0") + ";AbsSoftExtra=" + softExtra_local.ToString();

                            LogSetupRow("SkipFilters", "Short",
                                $"Space R={space.Rmultiple:F2} < {minSpace:F2} (eff)",
                                triggerPrice, plannedStopPrice, plannedTargetPrice, RewardMultiple,
                                Math.Abs(plannedStopPrice - triggerPrice) / Instrument.MasterInstrument.TickSize,
                                string.Format("SpaceFilter;SpaceR={0:F2};MinEff={1:F2};RiskT={2:F0};AdjNearT={3:F0};RawNearT={4:F0};TargetT={5:F0};IgnT={6:F0};EmaSlopeT={7:F0}{8}",
                                    space.Rmultiple,
                                    minSpace,
                                    space.RiskTicks,
                                    space.AdjNearTicks,
                                    space.RawNearTicks,
                                    targetTicks,
                                    (UseRZoneIgnore ? RZoneIgnoreBelowR * space.RiskTicks : 0.0),
                                    Math.Abs(ema[0] - ema[TrendSlopeLookback]) / Instrument.MasterInstrument.TickSize,
                                    extraNotes
                                )
                            );
                            armedLong = armedShort = false;
                            DrawStatusHud();
                            return;
                        }
                    }

                    
// BEFORE arming Short, compute quality → gate/size
{
    double minSpaceEff = EffectiveMinSpaceR();
    var spaceTmp = CheckSpaceFilter(false, triggerPrice, plannedStopPrice, SpaceLookback);
    ComputeQuality(false, minSpaceEff, spaceTmp,
                   out lastQSpace, out lastQTrend, out lastQSession, out lastQTotal, out lastQTotal2, out string qextra);

    if (UseQualityGate && lastQTotal2 < MinQTotal2)
    {
        LogSetupRow("SkipFilters", "Short",
            $"QualityGate QTotal2={lastQTotal2:F2} < {MinQTotal2:F2}",
            triggerPrice, plannedStopPrice, plannedTargetPrice, RewardMultiple,
            Math.Abs(plannedStopPrice - triggerPrice) / Instrument.MasterInstrument.TickSize,
            "QualityGate" + qextra);
        armedLong = armedShort = false;
        DrawStatusHud();
        Print("[MNQ QUALITY] Quality gate skipped trade");
        return;
    }

    double factor = (UseQualitySizing && lastQTotal2 < QTotal2SizeThreshold) ? SizeFactorLow : 1.0;
    lastPlannedQty = Math.Max(1, (int)Math.Round(BaseQty * factor));
    plannedQty = lastPlannedQty;
}

LogSetupRow("Armed", "Short", "", triggerPrice, plannedStopPrice, plannedTargetPrice, RewardMultiple,
                        Math.Abs(plannedStopPrice - triggerPrice) / Instrument.MasterInstrument.TickSize, "");
                    maeTicksWhileArmed = 0.0; maeRefPrice = Close[0];
                    armedShort = true; armedLong = false;
                }
                // ===== LONG (bullish cross) =====
                else if (Close[1] < ema1 && Close[0] > ema0)
                {
                    crossingCandleHigh = High[0];
                    crossingCandleLow  = Low[0];
                    setupBarIndex = CurrentBar;

                    triggerPrice       = crossingCandleHigh + EntryTicks * Instrument.MasterInstrument.TickSize;
                    plannedStopPrice   = crossingCandleLow - StopTicks * Instrument.MasterInstrument.TickSize;
                    plannedTargetPrice = triggerPrice + (triggerPrice - plannedStopPrice) * RewardMultiple;

                    if (UseSpaceFilter)
                    {
                        var space = CheckSpaceFilter(true, triggerPrice, plannedStopPrice, SpaceLookback);
                        double minSpace = EffectiveMinSpaceR();
                        minSpace = UseRZoneIgnore ? Math.Max(0.0, minSpace - RZoneIgnoreBelowR) : minSpace;

                        double targetTicks = Math.Abs(plannedTargetPrice - triggerPrice) / Instrument.MasterInstrument.TickSize;
                        double emaSlopeTicks_local = Math.Abs(ema[0] - ema[TrendSlopeLookback]) / Instrument.MasterInstrument.TickSize;
                        bool trendOK_local = !GateAbsByTrend ? true : (emaSlopeTicks_local >= Math.Max(1.0, TrendSlopeMinTicks));
                        int softExtra_local = (GateAbsSoftTier && emaSlopeTicks_local < Math.Max(1.0, TrendSlopeMinTicks)) ? 1 : 0;
                        bool passByAbs = (space.RawNearTicks >= (MinAbsSpaceTicks + softExtra_local)) && (!GateAbsByTrend || trendOK_local);
                        bool passByBeyondTarget = space.RawNearTicks >= targetTicks;

                        if (!(passByAbs || passByBeyondTarget) && space.Rmultiple < minSpace)
                        {
                            string extraNotes = string.Empty;
                            if (LogQualityTelemetry)
                            {
                                double emaSlopeTicks = emaSlopeTicks_local;
                                double r_rel = space.RiskTicks > 0 ? (space.AdjNearTicks / space.RiskTicks) : 0.0;
                                double qSpace = (space.RawNearTicks >= MinAbsSpaceTicks) ? Math.Min(1.0, (minSpace > 0 ? r_rel / minSpace : 1.0)) : 0.0;
                                double qTrend = Math.Min(1.0, emaSlopeTicks / Math.Max(1.0, TrendSlopeMinTicks));

                                double deltaM = 0.0; int aH=AnchorHour, aM=AnchorMinute, aIdx=1; string shapeUsed="Gaussian";
                                double qSession = 1.0;
                                if (UseSessionAnchor)
                                {
                                    deltaM = MinutesToNearestAnchor(out aH, out aM, out aIdx);
                                    double proximity = SessionProximity(deltaM, out shapeUsed);
                                    double nowM = Time[0].TimeOfDay.TotalMinutes;
                                    double aMin = aH*60.0 + aM;
                                    bool isPost = ((nowM - aMin + 1440.0) % 1440.0) <= 720.0 ? (nowM >= aMin) : (nowM < aMin);
                                    double asym = isPost ? PostScale : PreScale;
                                    bool withTrend = (ema[0] > ema[TrendSlopeLookback]);
                                    double adj = SessionPenalty * asym * proximity;
                                    qSession = Clamp01(SessionReversalBias ? (withTrend ? (1.0 - adj) : (1.0 + 0.25 * adj)) : (1.0 - adj));
                                }
                                double qTotal = Clamp01(W_Space * qSpace + W_Trend * qTrend);
                                double qTotal2 = Clamp01(qTotal + W_Session * (UseSessionAnchor ? 1.0 : 0.0) * (UseSessionAnchor ? 1.0 : 0.0)); // keep form

                                AppendSessionNotes(ref extraNotes, qSession, deltaM, aH, aM, shapeUsed, aIdx, qTotal2);
                                extraNotes += string.Format(";QSpace={0:F2};QTrend={1:F2};QTotal={2:F2}", qSpace, qTrend, qTotal);
                            }
                            extraNotes += ";AbsTrendOK=" + (trendOK_local ? "1" : "0") + ";AbsSoftExtra=" + softExtra_local.ToString();

                            LogSetupRow("SkipFilters", "Long",
                                $"Space R={space.Rmultiple:F2} < {minSpace:F2} (eff)",
                                triggerPrice, plannedStopPrice, plannedTargetPrice, RewardMultiple,
                                Math.Abs(plannedStopPrice - triggerPrice) / Instrument.MasterInstrument.TickSize,
                                string.Format("SpaceFilter;SpaceR={0:F2};MinEff={1:F2};RiskT={2:F0};AdjNearT={3:F0};RawNearT={4:F0};TargetT={5:F0};IgnT={6:F0};EmaSlopeT={7:F0}{8}",
                                    space.Rmultiple,
                                    minSpace,
                                    space.RiskTicks,
                                    space.AdjNearTicks,
                                    space.RawNearTicks,
                                    targetTicks,
                                    (UseRZoneIgnore ? RZoneIgnoreBelowR * space.RiskTicks : 0.0),
                                    Math.Abs(ema[0] - ema[TrendSlopeLookback]) / Instrument.MasterInstrument.TickSize,
                                    extraNotes
                                )
                            );
                            armedLong = armedShort = false;
                            DrawStatusHud();
                            return;
                        }
                    }

                    LogSetupRow("Armed", "Long", "", triggerPrice, plannedStopPrice, plannedTargetPrice, RewardMultiple,
                        Math.Abs(plannedStopPrice - triggerPrice) / Instrument.MasterInstrument.TickSize, "");
                    maeTicksWhileArmed = 0.0; maeRefPrice = Close[0];
                    armedLong = true; armedShort = false;
                }
            }

            // ---- Auto-expire ----
            if ((armedLong || armedShort) && CurrentBar - setupBarIndex > SetupExpiryBars)
            {
                LogSetupRow("Expired", armedLong ? "Long" : "Short", "OrderNotTriggered",
                    triggerPrice, plannedStopPrice, plannedTargetPrice, RewardMultiple,
                    Math.Abs(plannedStopPrice - triggerPrice) / Instrument.MasterInstrument.TickSize,
                    "SetupExpiry (> " + SetupExpiryBars + " bars)");
                armedLong = armedShort = false;
                DrawStatusHud();
                return;
            }

            // ---- Place orders ----
            if (Position.MarketPosition == MarketPosition.Flat)
            {
                if (armedLong && High[0] >= crossingCandleHigh + EntryTicks * Instrument.MasterInstrument.TickSize)
                {
                    SetStopLoss("LongEntry", CalculationMode.Price, plannedStopPrice, false);
                    SetProfitTarget("LongEntry", CalculationMode.Price, plannedTargetPrice, false);
                    EnterLongLimit(plannedQty, triggerPrice, "LongEntry");
                    LogSetupRow("OrderPlaced", "Long", "", triggerPrice, plannedStopPrice, plannedTargetPrice,
                        RewardMultiple, Math.Abs(plannedStopPrice - triggerPrice) / Instrument.MasterInstrument.TickSize, "EnterLongLimit");
                    armedLong = false;
                }
                else if (armedShort && Low[0] <= crossingCandleLow - EntryTicks * Instrument.MasterInstrument.TickSize)
                {
                    SetStopLoss("ShortEntry", CalculationMode.Price, plannedStopPrice, false);
                    SetProfitTarget("ShortEntry", CalculationMode.Price, plannedTargetPrice, false);
                    EnterShortLimit(plannedQty, triggerPrice, "ShortEntry");
                    LogSetupRow("OrderPlaced", "Short", "", triggerPrice, plannedStopPrice, plannedTargetPrice,
                        RewardMultiple, Math.Abs(plannedStopPrice - triggerPrice) / Instrument.MasterInstrument.TickSize, "EnterShortLimit");
                    armedShort = false;
                }
            }

            DrawStatusHud();
        }

        // ===========================
        // FILLS
        // ===========================
        protected override void OnExecutionUpdate(Cbi.Execution execution, string executionId, double price, int quantity,
                                                  Cbi.MarketPosition marketPosition, string orderId, DateTime time)
        {
            if (execution?.Order == null || execution.Order.OrderState != OrderState.Filled)
                return;

            if (execution.Order.Name == "LongEntry" || execution.Order.Name == "ShortEntry")
            {
                if (execution.Order.Name == "LongEntry")
                {
                    double structStop = crossingCandleLow - StopTicks * Instrument.MasterInstrument.TickSize;
                    double tgt = price + (price - structStop) * RewardMultiple;
                    SetStopLoss("LongEntry", CalculationMode.Price, structStop, false);
                    SetProfitTarget("LongEntry", CalculationMode.Price, tgt, false);
                    tradeSide = MarketPosition.Long;
                }
                else
                {
                    double structStop = crossingCandleHigh + StopTicks * Instrument.MasterInstrument.TickSize;
                    double tgt = price - (structStop - price) * RewardMultiple;
                    SetStopLoss("ShortEntry", CalculationMode.Price, structStop, false);
                    SetProfitTarget("ShortEntry", CalculationMode.Price, tgt, false);
                    tradeSide = MarketPosition.Short;
                }
                string suffix = CurrentBar + "_" + execution.Order.Name + "_" + time.ToString("HHmmssfff");
                Draw.HorizontalLine(this, "EntryLine_" + suffix, price, Brushes.DodgerBlue);
                double stopLine = (execution.Order.Name == "LongEntry")
                    ? crossingCandleLow - StopTicks * Instrument.MasterInstrument.TickSize
                    : crossingCandleHigh + StopTicks * Instrument.MasterInstrument.TickSize;
                double tgtLine = (execution.Order.Name == "LongEntry")
                    ? price + (price - stopLine) * RewardMultiple
                    : price - (stopLine - price) * RewardMultiple;
                Draw.HorizontalLine(this, "StopLine_"   + suffix, stopLine, Brushes.OrangeRed);
                Draw.HorizontalLine(this, "TargetLine_" + suffix, tgtLine,  Brushes.MediumSeaGreen);

                inTrade = true;
                tradeEntryPrice = price;
                tradeEntryTime  = time;
                return;
            }

            if (inTrade && Position.MarketPosition == MarketPosition.Flat)
            {
                double exitPrice = execution.Price;
                double resultTicks = 0.0;
                if (tradeSide == MarketPosition.Long)  resultTicks = (exitPrice - tradeEntryPrice) / Instrument.MasterInstrument.TickSize;
                if (tradeSide == MarketPosition.Short) resultTicks = (tradeEntryPrice - exitPrice) / Instrument.MasterInstrument.TickSize;
                double resultUsd = resultTicks * Instrument.MasterInstrument.PointValue;

                double stopP = (tradeSide == MarketPosition.Long)
                    ? crossingCandleLow - StopTicks * Instrument.MasterInstrument.TickSize
                    : crossingCandleHigh + StopTicks * Instrument.MasterInstrument.TickSize;
                double targetP = (tradeSide == MarketPosition.Long)
                    ? tradeEntryPrice + (tradeEntryPrice - stopP) * RewardMultiple
                    : tradeEntryPrice - (stopP - tradeEntryPrice) * RewardMultiple;

                LogTradeRow(tradeSide == MarketPosition.Long ? "Long" : "Short",
                    tradeEntryPrice, stopP, targetP, RewardMultiple, plannedQty,
                    exitPrice, resultTicks, resultUsd, execution.Order.Name);

                inTrade = false;
                tradeSide = MarketPosition.Flat;
                tradeEntryPrice = 0;
                tradeEntryTime  = DateTime.MinValue;
            }
        }

        protected override void OnOrderUpdate(Cbi.Order order, double limitPrice, double stopPrice, int quantity,
                                              int filled, double averageFillPrice, Cbi.OrderState orderState,
                                              DateTime time, Cbi.ErrorCode error, string comment)
        {
            if (order == null || order.Name == null) return;
            if ((orderState == OrderState.Cancelled || orderState == OrderState.Rejected) &&
                (order.Name == "LongEntry" || order.Name == "ShortEntry"))
            {
                Print($"[ORDER {orderState}] {order.Name}  Reason={comment}");
                armedLong = armedShort = false;
            }
        }

        // ===========================
        // CONFIG ECHO
        // ===========================
        private string BuildParamEcho()
        {
            try
            {
                var parts = new List<string>();
                parts.Add("Build=SESSION_SHAPES_CONFIGECHO_SAFE");
                // Core filters/space
                parts.Add("UseSpaceFilter=" + UseSpaceFilter);
                parts.Add("MinSpaceR=" + MinSpaceR.ToString("F2"));
                parts.Add("UseRZoneIgnore=" + UseRZoneIgnore);
                parts.Add("RZoneIgnoreBelowR=" + RZoneIgnoreBelowR.ToString("F2"));
                parts.Add("MinAbsSpaceTicks=" + MinAbsSpaceTicks.ToString("F0"));
                parts.Add("GateAbsByTrend=" + GateAbsByTrend);
                parts.Add("GateAbsSoftTier=" + GateAbsSoftTier);
                // Trend
                parts.Add("TrendSlopeLookback=" + TrendSlopeLookback);
                parts.Add("TrendSlopeMinTicks=" + TrendSlopeMinTicks);
                // ATR buffer
                parts.Add("UseAtrBuffer=" + UseAtrBuffer);
                parts.Add("AtrBufferTicks=" + AtrBufferTicks);
                // Space windows
                parts.Add("SpaceLookback=" + SpaceLookback);
                parts.Add("SpaceIgnoreBars=" + SpaceIgnoreBars);
                // Swing / context
                parts.Add("UseSwingOnly=" + UseSwingOnly);
                parts.Add("SwingStrength=" + SwingStrength);
                parts.Add("UseTrendAwareSpace=" + UseTrendAwareSpace);
                parts.Add("TrendMinSpaceR=" + TrendMinSpaceR.ToString("F2"));
                // Time filter
                parts.Add("UseTimeFilter=" + UseTimeFilter);
                parts.Add("SessionStart=" + SessionStart);
                parts.Add("SessionEnd=" + SessionEnd);
                // Session anchors & shape
                parts.Add("UseSessionAnchor=" + UseSessionAnchor);
                parts.Add("AnchorHour=" + AnchorHour);
                parts.Add("AnchorMinute=" + AnchorMinute);
                parts.Add("AnchorWindowMins=" + AnchorWindowMins);
                parts.Add("SessionWindowShape=" + SessionWindowShape);
                parts.Add("SessionPenalty=" + SessionPenalty.ToString("F2"));
                parts.Add("SessionReversalBias=" + SessionReversalBias);
                parts.Add("PreScale=" + PreScale.ToString("F2"));
                parts.Add("PostScale=" + PostScale.ToString("F2"));
                parts.Add("W_Session=" + W_Session.ToString("F2"));

parts.Add("BaseQty=" + BaseQty);
parts.Add("UseQualityGate=" + UseQualityGate);
parts.Add("MinQTotal2=" + MinQTotal2.ToString("F2"));
parts.Add("UseQualitySizing=" + UseQualitySizing);
parts.Add("QTotal2SizeThreshold=" + QTotal2SizeThreshold.ToString("F2"));
parts.Add("SizeFactorLow=" + SizeFactorLow.ToString("F2"));

                parts.Add("UseAnchor2=" + UseAnchor2);
                parts.Add("Anchor2Hour=" + Anchor2Hour);
                parts.Add("Anchor2Minute=" + Anchor2Minute);
                parts.Add("UseAnchor3=" + UseAnchor3);
                parts.Add("Anchor3Hour=" + Anchor3Hour);
                parts.Add("Anchor3Minute=" + Anchor3Minute);
                return string.Join(";", parts);
            }
            catch
            {
                return "ParamEchoError=1";
            }
        }

        // ===========================
        // HUD
        // ===========================
        private void DrawStatusHud()
        {
            string tag = "MNQRS_HUD";
            string text;
            if (Position.MarketPosition == MarketPosition.Flat)
            {
                if (armedLong || armedShort)
                {
                    text = "ENTRY ARMED  " + (armedLong ? "Long" : "Short") + "\n" +
                           $"Trig:{triggerPrice:F2}  Stp:{plannedStopPrice:F2}  Tgt:{plannedTargetPrice:F2}\n" +
                           $"R:{RewardMultiple:F1}  Qty:{plannedQty}";
                }
                else text = " ";
            }
            else
            {
                double entry = Position.AveragePrice;
                double stop = (Position.MarketPosition == MarketPosition.Long)
                              ? crossingCandleLow - StopTicks * Instrument.MasterInstrument.TickSize
                              : crossingCandleHigh + StopTicks * Instrument.MasterInstrument.TickSize;

                double target = (Position.MarketPosition == MarketPosition.Long)
                                ? entry + (entry - stop) * RewardMultiple
                                : entry - (stop - entry) * RewardMultiple;

                text = (Position.MarketPosition == MarketPosition.Long ? "LONG" : "SHORT") + " ACTIVE\n" +
                       $"Entry:{entry:F2}  Stop:{stop:F2}  Tgt:{target:F2}\n" +
                       $"R:{RewardMultiple:F1}  Qty:{Position.Quantity}";
            }
            Draw.TextFixed(this, tag, text, TextPosition.BottomRight,
                           Brushes.Gainsboro, hudFont,
                           Brushes.Transparent, Brushes.Transparent, 0);
        }
    } // end class
} // end namespace
